{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Important Previously finished tasks from before release Once v0.1.0 migrated to here Todo [6] Submit working demo/mvp/proof-of-concept Dev v0.0.1 (not unit tested, only for demo) Github release viewable here [7] Submit demo videos [8] Write User Guide: 1. Installation 2. Running an instance 3. Changing the configuration 4. Running multiple instances 5. Monitoring Positions Afterwards add screenshots to all of those pages [9] Work on all the steps required for the first stable & unit tested release v0.1.0 (planned) [10] Collaboratively plan which features which will be released incrementally in order of priority, clarifying the criteria for each to be fulfilled & assign planned version numbers to make tracking progress more objective. 1. Demo Audio quality of my mic sounds like a tin can, so apologies for that. Once v0.1.0 is released, I'll record new videos with concise & easy to follow guides for users, and seperate guides for developers (And I'll get a better mic first) Also, the first two videos were recorded after the third video so when I refer to the previous video I mean the third video. Th first video ends abruptly since it is the same video as the second one and I just chopped it into two. EDIT: Minor correction to what I say in the video: When it's in debug mode it's not actually listening for signals, and it's only asking for the prompt. I can however change it so that it is doing both at the same time. If you disable debug_mode, then it will actually be waiting for real signals. 2. Looking at the code 3. Octobot vs. FreqTrade (Thankfully I don't charge per hour...) I know I can eventually deliver a high quality, reliable and properly tested product if I spend enough time on it. Some of this time was spent on other things, but most of the time was actually spent on your project. I'll be able to see a more detailed breakdown when I get WakaTime Premium In these docs I will explain how this program works and its architecture, and try to make it easy to understand for both users or developers. This initially started out as a way to implement a single strategy ie. the SuperTrend Long/Short Strategy, but it's designed in a way to be scalable for use with other strategies and exchanges, and have things abstracted in such a way that each strategy only needs to deal with checking indicator signals, and opening/closing positions, instead of having to think about the underlying trades that comprise the positions while writing a new strategy. It will also generate a report whenever a trade is opened or closed, then save it to a log file, and if notifications are enabled then it will send notifications either via email or telegram or both including information about each position, which strategy it's from, which pair, the signals taken, trades opened, timestamps, PnL, etc It should be possible out of the box to use margin trading for any exchange which ccxt has implemented that for, which unfortunately is not unified nor implemented for some exchanges, unlike some other unified methods for things like fetching market data, opening trades, etc. Unfortunately, KuCoin falls into that category of not having margin trading implemented currently, so I've had to implement that myself by: Extending the default ccxt.kucoin in core.exchanges.kucoin_extended and overriding the methods so that it does still support margin trading. the default method ccxt uses for margin trading is exchange.fetch_borrow_rate() but KuCoin's API doesn't have that, and it's only possible to get the max borrow amount I've added a new method kucoin_extended.fetch_max_borrow_size , and I'm going to override the fetch_borrow_rate() method so that it calculates what the rate would be if that's possible? And then it would be possible for me to unify how all the strategies are implemented in this codebase so they always use the same abstractions. I should make a wrapper method which handles which one to use but for now that has to be done inside the strategy. Objectives & Requirements SuperTrend Strategy Activity Diagram from earlier This is a platform that's designed for pairs trading strategies. Pairs trading is when you take two tradeable pairs eg. ETH/USDT and BTC/USDT and combine them to make what can be called an 'artificial', 'synthetic', or 'double' pair (I may use those names interchangeably in these docs) by dividing each of the OHLCV data points in the base currency by the quote currency ie. ETHUSDT/BTCUSDT Each position in a pairs trade is composed of at least two trades, with one for each sub-pair: To open a short position on the artificial pair ETHUSDT/BTCUSDT , that requires going short on the base pair ETH/USDT (ie. Sell ETH for USDT), and then going long on the quote pair BTC/USDT (ie. Buy BTC with USDT) Conversely, to open a long position on ETHUSDT/BTCUSDT , that requires going short on the quote pair BTC/USDT (ie. Sell BTC for USDT), and then going long on the base pair ETH/USDT (ie. Buy ETH with USDT) The position's PnL is calculated by adding the PnL from each trade together. The reason the short trade should be opened before the long trade, is so that borrowed margin can be used to sell the short asset, and the resulting asset from that trade can be funneled into the long trade. ETH/USDT :D1:KUCOIN BTC/USDT :D1:KUCOIN ETHUSDT/BTCUSDT :D1:KUCOIN","title":"Readme"},{"location":"#1-demo","text":"Audio quality of my mic sounds like a tin can, so apologies for that. Once v0.1.0 is released, I'll record new videos with concise & easy to follow guides for users, and seperate guides for developers (And I'll get a better mic first) Also, the first two videos were recorded after the third video so when I refer to the previous video I mean the third video. Th first video ends abruptly since it is the same video as the second one and I just chopped it into two. EDIT: Minor correction to what I say in the video: When it's in debug mode it's not actually listening for signals, and it's only asking for the prompt. I can however change it so that it is doing both at the same time. If you disable debug_mode, then it will actually be waiting for real signals.","title":"1. Demo"},{"location":"#2-looking-at-the-code","text":"","title":"2. Looking at the code"},{"location":"#3-octobot-vs-freqtrade","text":"(Thankfully I don't charge per hour...) I know I can eventually deliver a high quality, reliable and properly tested product if I spend enough time on it. Some of this time was spent on other things, but most of the time was actually spent on your project. I'll be able to see a more detailed breakdown when I get WakaTime Premium In these docs I will explain how this program works and its architecture, and try to make it easy to understand for both users or developers. This initially started out as a way to implement a single strategy ie. the SuperTrend Long/Short Strategy, but it's designed in a way to be scalable for use with other strategies and exchanges, and have things abstracted in such a way that each strategy only needs to deal with checking indicator signals, and opening/closing positions, instead of having to think about the underlying trades that comprise the positions while writing a new strategy. It will also generate a report whenever a trade is opened or closed, then save it to a log file, and if notifications are enabled then it will send notifications either via email or telegram or both including information about each position, which strategy it's from, which pair, the signals taken, trades opened, timestamps, PnL, etc It should be possible out of the box to use margin trading for any exchange which ccxt has implemented that for, which unfortunately is not unified nor implemented for some exchanges, unlike some other unified methods for things like fetching market data, opening trades, etc. Unfortunately, KuCoin falls into that category of not having margin trading implemented currently, so I've had to implement that myself by: Extending the default ccxt.kucoin in core.exchanges.kucoin_extended and overriding the methods so that it does still support margin trading. the default method ccxt uses for margin trading is exchange.fetch_borrow_rate() but KuCoin's API doesn't have that, and it's only possible to get the max borrow amount I've added a new method kucoin_extended.fetch_max_borrow_size , and I'm going to override the fetch_borrow_rate() method so that it calculates what the rate would be if that's possible? And then it would be possible for me to unify how all the strategies are implemented in this codebase so they always use the same abstractions. I should make a wrapper method which handles which one to use but for now that has to be done inside the strategy.","title":"3. Octobot vs. FreqTrade"},{"location":"#objectives-requirements","text":"SuperTrend Strategy Activity Diagram from earlier This is a platform that's designed for pairs trading strategies. Pairs trading is when you take two tradeable pairs eg. ETH/USDT and BTC/USDT and combine them to make what can be called an 'artificial', 'synthetic', or 'double' pair (I may use those names interchangeably in these docs) by dividing each of the OHLCV data points in the base currency by the quote currency ie. ETHUSDT/BTCUSDT Each position in a pairs trade is composed of at least two trades, with one for each sub-pair: To open a short position on the artificial pair ETHUSDT/BTCUSDT , that requires going short on the base pair ETH/USDT (ie. Sell ETH for USDT), and then going long on the quote pair BTC/USDT (ie. Buy BTC with USDT) Conversely, to open a long position on ETHUSDT/BTCUSDT , that requires going short on the quote pair BTC/USDT (ie. Sell BTC for USDT), and then going long on the base pair ETH/USDT (ie. Buy ETH with USDT) The position's PnL is calculated by adding the PnL from each trade together. The reason the short trade should be opened before the long trade, is so that borrowed margin can be used to sell the short asset, and the resulting asset from that trade can be funneled into the long trade.","title":"Objectives &amp; Requirements"},{"location":"#ethusdtd1kucoin","text":"","title":"ETH/USDT:D1:KUCOIN"},{"location":"#btcusdtd1kucoin","text":"","title":"BTC/USDT:D1:KUCOIN"},{"location":"#ethusdtbtcusdtd1kucoin","text":"","title":"ETHUSDT/BTCUSDT:D1:KUCOIN"},{"location":"How_it_works/","text":"How it works: [Note] This is a work in progress and I can't garauntee everything works 100% until this note says otherwise, after doing unit tests for everything. I am also still debugging and there are still a couple more things I have to add before it's operational, but should hopefully have that sorted later today (15th). \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 This is the sequence of events that happens when you run the bot. I'm writing this to explain what's going on, and also to be able to properly write unit tests to ensure that it's actually working as it should. Eventually, each heading in this document will get its own documentation page but this should help to clarify how the execution sequence from start to end should be. 1. Start the bot: From a terminal, run python __main__.py Inside __main__.py , the run_bot() function is called which takes the optional param strategy= . When it's not specified, it currently defaults to strategy=N2SuperTrend() which initializes the strategy. if __name__ == '__main__' : run_bot () # Can pass a Strategy to override default eg. run_bot(strategy=YourStrategy) you can edit this part of __main__.py to override the default strategy. you also need to import the Strategy at the top of __main__ : from strategies.another_strategy import AnotherStrategy ... if __name__ == '__main__' : run_bot ( strategy = AnotherStrategy ()) TODO : I want to make it so that it you can pass the strategy as an argument from terminal, which could be useful for implementing backtesting 2.1 Initialize strategy When a strategy class eg. N2SuperTrend is initialized without params then it loads the values set in user/user-config.ini def run_bot ( strategy = N2SuperTrend ()): ... At this point, you can access the following Fields inherited by StrategyBase : strategy . exchange : str , strategy . strategy_name : str , strategy . prompt_for_pairs : bool , strategy . base_pair : str , strategy . quote_pair : str , strategy . synth_pair : str , # Not sure if this is set properly by __init__ yet strategy . stake_currency : str , strategy . paper_trade : bool , strategy . position_manager : PositionManager , strategy . previous_tick : datetime , strategy . ohlcv_data : dict , strategy . signal : str , strategy . multi_timeframe_mode : bool strategy . multi_timeframe_signal_rules : dict 2.2 How a strategy is initialized behind the scenes: What happens when the strategy object is instantiated eg. strategy = N2SuperTrend() is that the __init__ method inside the N2SuperTrend class is called: class N2SuperTrend ( StrategyBase ): def __init__ ( self , params = {}, config_filepath = USER_CONFIG_PATH ): \"\"\" The first line `super().__init__(params, config_filepath)` means it runs the __init__ method in StrategyBase and inherits its attributes from there, then the name is set. :param params: :type params: :param config_filepath: :type config_filepath: \"\"\" super () . __init__ ( params , config_filepath ) self . name = 'n2_supertrend' This is all you'd need to put in the __init__ of any new strategy, and then put the strategy's logic for how it generates a signal inside of the method YourStrategy.get_signal() Like it says in the comment, the super() function on the first line runs the __init__ of the StrategyBase class so it inherits all the attributes and methods of StrategyBase and then it assigns a name for the strategy. Here's what's happening in StrategyBase.__init__() where the program executes next before coming back to N2SuperTrend : from core.config import Config class StrategyBase ( Config ): \"\"\" A strategy is an object whose main purpose is to contain regularly updated market data by pulling OHLCV data from both the base pair and the quote pair, then combining them to make the synth pair, keeping track of PnL for both underlying trades. The main logic which is specific to your strategy should be implemented in the `get_signal()` method which should then be called at a regular defined interval. The signal can be set either to be for a single timeframe or multiple timeframes by setting the value of `multi_timeframe_signal_mode: Bool` for that strategy. \"\"\" ... def __int__ ( self , params = {}, config_filepath = USER_CONFIG_PATH ): \"\"\" The first line: `super().__init__(params, config_filepath)` means it runs the __init__ method in Config and inherits its attributes from there, then after that, the other attributes are set. :param params: :type params: :param config_filepath: :type config_filepath: :return: :rtype: \"\"\" super () . __init__ ( self , params , config_filepath ) self . name = None self . current_signal = None self . position_manager = PositionManager () The StrategyBase class inherits the Config class and calls the super() function on the first line too, which calls the __init__() of Config . Config doesn't inherit anything and it's a base class for other classes to inherit. It provides an extra layer between the strategy and lower level configuration options eg. [TODO] OHCLV data source should be configurable so that later when making a backtesting environment that will be given historic market data and a much faster tick interval, it will be possible to have multiple instances of running strategies configured differently. It shouldn't need to be edited unless developing/debugging): This is what happens in Config.__init__() where the program executes next before coming back to StrategyBase.__init__() . class Config : __dict__ = { \"exchange\" : str , \"strategy_name\" : str , \"prompt_for_pairs\" : bool , \"base_pair\" : str , \"quote_pair\" : str , \"stake_currency\" : str , \"paper_trade\" : bool , \"debug_mode\" : bool } cfg_parser = ConfigParser () def __init__ ( self , params = {}, filepath = USER_CONFIG_PATH ): \"\"\" **[TODO]**: the API Keys should be read from the config.ini file or given as params then saved in self.exchange_api_keys: dict instead of how I'm currently handling how API keys are accessed which isn't the best way. Then, self.exchange can be initialized taking self.exchange_api_keys as a param. \"\"\" self . params = params if params is None or len ( params ) == 0 : if filepath is not None : self . cfg_parser . read ([ filepath ]) elif filepath is None : raise ValueError try : self . exchange_id = self . cfg_parser [ 'Global Settings' ][ 'exchange' ] self . strategy_name = self . cfg_parser [ 'Global Settings' ][ 'strategy' ] self . strategy_import_path = f \"strategies. { self . strategy_name } \" self . prompt_for_pairs = bool ( self . cfg_parser [ 'Global Settings' ][ 'prompt_for_pairs' ]) self . base_pair = self . cfg_parser [ 'Global Settings' ][ 'base_pair_default' ] self . quote_pair = self . cfg_parser [ 'Global Settings' ][ 'quote_pair_default' ] self . stake_currency = self . cfg_parser [ 'Global Settings' ][ 'stake_currency' ] self . paper_trade = bool ( self . cfg_parser [ 'Global Settings' ][ 'paper_trade' ]) # self.synth_pair = self.get_synth_pair_symbol(self.base_pair, self.quote_pair) # self.strategy = importlib.import_module(f\"strategies.{self.strategy_name}\") # self.exchange: ccxt.Exchange = self.enabled_exchanges[self.cfg_file_key] except : raise ValueError ( \"Failed to read from config (Make sure all values are assigned)\" ) elif self . params is not None : for param in self . params : if param not in self . __dict__ : raise ValueError ( f \"Invalid Parameter: ' { param } '\" ) try : self . exchange_id : str = self . params [ 'exchange' ] self . strategy_name = self . params [ 'strategy' ] self . strategy_import_path = f \"strategies. { self . strategy_name [ 'strategy' ] } \" self . prompt_for_pairs : bool = params [ 'prompt_for_pairs' ], self . base_pair : str = params [ 'base_pair' ], self . quote_pair : str = params [ 'quote_pair' ], self . stake_currency : str = params [ 'stake_currency' ] self . paper_trade : bool = params [ 'paper_trade' ] # self.strategy = importlib.import_module(f\"strategies.{self.strategy_name}\") # self.exchange: ccxt.Exchange = self.enabled_exchanges[self.cfg_file_key] except : raise ValueError ( \"Params incomplete\" ) else : raise Exception ( \"Cannot Initialize Config() without either params or config_filepath\" ) self . synth_pair = utils . get_synth_pair_tuple ( self . base_pair , self . quote_pair ) self . enabled_exchanges = self . get_enabled_exchanges () self . exchange : ccxt . Exchange = self . enabled_exchanges [ self . exchange_id . lower ()] What it's doing is checking to see if params were supplied to override the default config. If params are passed to Config or any of its subclasses ie. StrategyBase or N2SuperTrend are instantiated, then it will load those params as a configuration. If params are not supplied, it will use a config.ini file specified by filepath , which defaults to the global constant USER_CONFIG_PATH (This is set in core.constants to user/user-config.ini ) 3.1 After strategy is initialized: It will have its own ccxt.Exchange type initialized with api keys read from the user config and PositionManager object as a Fields and which can be accessed from inside or outside of the strategy class (better inside): Going back to the run_bot() function in main .py: def run_bot ( strategy = N2SuperTrend ()): running = True pm : PositionManager = strategy . position_manager while running : if strategy . debug_mode : \"\"\"If in debug mode, prompt for signal override\"\"\" override_signal = input ( \"[DEBUG]Enter a signal to emulate: ([LONG]|SHORT|CLOSE)\" ) if override_signal == \"\" : signal = 'LONG' # Default if you just press enter at the prompt elif override_signal . upper () == 'SHORT' or override_signal == 'LONG' : signal = override_signal else : \"\"\"If not in debug mode, call the get_signal method of the strategy\"\"\" signal = strategy . listen_for_signals () ... if __name__ == '__main__' : run_bot () # Can pass a Strategy to override default eg. main(strategy=YourStrategy) First, the strategy's PositionManager is assigned to the variable pm (can be called anything) Then, it enters a while loop: while running: This while loop is essentially one tick, and it would be better to move this out of __main__.py and into a a new method of StrategyBase or Config : called run() or start() The I haven't yet accounted for rate limits, but it's possible to fetch rate limits for an exchange with ccxt. 3.2 Getting a signal from the strategy When the strategy.get_signal method is called, it will run whatever logic you have defined in that method for your strategy. If you don't create a method in your strategy called get_signal , it will default to the one in StrategyBase and raise a NotImplemented error: Otherwise, when you do define a get_signal method, it will override the one in StrategyBase and you can implement whatever logic and conditions to generate the strategy's net signal in that method. The signal can either based on one timeframe or you can enable and define Multi-timeframe signal rules as a dict with keys for each timeframe that have bool values. Whichever timeframes are set to true, must reach a consensus of their signals for them to generate an aggregated signal. [TODO] : make it so that in multi-timeframe mode, instead of fetching signals for all timeframes at every tick, they will each have different intervals to stay within rate limits. I also need to change how get_signal is currently fetching historic bars every time it's called when it should only need to do that once, and then update the price with live tick data from by using ccxt.Exchange.fetch_ticker() def run_bot ( strategy = N2SuperTrend ()): running = True pm : PositionManager = strategy . position_manager while running : ... signal = strategy . listen_for_signals () if signal is not None and signal != 'CLOSE' : \"\"\"If there is a new signal to LONG or SHORT:\"\"\" if pm . get_current_position () is None : \"\"\" If there's no current position open, then open one in the signal of the signal and set it as pm's current_position \"\"\" position = Position ( strategy . base_pair , strategy . quote_pair , direction = signal , order_type = 'limit' ) . open () # TODO: Here is where the `core.notifier` class would be # used to report the opening of the position and send # send a notification via telegram and/or email. pm . set_current_position ( position ) elif signal == 'CLOSE' : \"\"\" If the signal is 'CLOSE', then close the pm.current_position \"\"\" pm . current_position . close () # TODO: Here `core.notifier` would be used again to report # the closing of the trade and send via email/telegram tick_interval = 60 # This should be adjusted to take API rate limits into account \"\"\"For now the tick_interval is set here, but it should be set by params config file by Config.__init__()\"\"\" time . sleep ( tick_interval ) # await asyncio.sleep(tick_interval) 4. Opening a Position: 5. Closing a position: 6. Generating report notifications: 7. Further ideas: 7.1 Saving reports to a database? 7.2 Backtesting engine 7.2.1 This should be done in a lower level language eg. Cython which is python compiled into .pyx / .pyd C-like modules with python syntax that can be accessed as normal modules but run compiled machine code is run instead of having a runtime interperet the script. Cython is also what Hummingbot uses for calculation-intensive modules. 7.3 Combine with triangular arbitrage strategy, using any exposed coins in an open position as stake currencies that execute arbitrage signals and be returned back to the same coin to resume the position 7.4 Add support for normal trading pairs, not just combined trading pairs","title":"How it works:"},{"location":"How_it_works/#how-it-works","text":"","title":"How it works:"},{"location":"How_it_works/#notethis-is-a-work-in-progress-and-i-cant-garauntee-everything-works-100-until-this-note-says-otherwise-after-doing-unit-tests-for-everything-i-am-also-still-debugging-and-there-are-still-a-couple-more-things-i-have-to-add-before-its-operational-but-should-hopefully-have-that-sorted-later-today-15th","text":"\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 This is the sequence of events that happens when you run the bot. I'm writing this to explain what's going on, and also to be able to properly write unit tests to ensure that it's actually working as it should. Eventually, each heading in this document will get its own documentation page but this should help to clarify how the execution sequence from start to end should be.","title":"[Note]This is a work in progress  and I can't garauntee everything works 100% until this note says otherwise, after doing unit tests for everything. I am also still debugging and there are still a couple more things I have to add before it's operational, but should hopefully have that sorted later today (15th)."},{"location":"How_it_works/#1-start-the-bot","text":"From a terminal, run python __main__.py Inside __main__.py , the run_bot() function is called which takes the optional param strategy= . When it's not specified, it currently defaults to strategy=N2SuperTrend() which initializes the strategy. if __name__ == '__main__' : run_bot () # Can pass a Strategy to override default eg. run_bot(strategy=YourStrategy) you can edit this part of __main__.py to override the default strategy. you also need to import the Strategy at the top of __main__ : from strategies.another_strategy import AnotherStrategy ... if __name__ == '__main__' : run_bot ( strategy = AnotherStrategy ()) TODO : I want to make it so that it you can pass the strategy as an argument from terminal, which could be useful for implementing backtesting","title":"1. Start the bot:"},{"location":"How_it_works/#21-initialize-strategy","text":"When a strategy class eg. N2SuperTrend is initialized without params then it loads the values set in user/user-config.ini def run_bot ( strategy = N2SuperTrend ()): ... At this point, you can access the following Fields inherited by StrategyBase : strategy . exchange : str , strategy . strategy_name : str , strategy . prompt_for_pairs : bool , strategy . base_pair : str , strategy . quote_pair : str , strategy . synth_pair : str , # Not sure if this is set properly by __init__ yet strategy . stake_currency : str , strategy . paper_trade : bool , strategy . position_manager : PositionManager , strategy . previous_tick : datetime , strategy . ohlcv_data : dict , strategy . signal : str , strategy . multi_timeframe_mode : bool strategy . multi_timeframe_signal_rules : dict","title":"2.1 Initialize strategy"},{"location":"How_it_works/#22-how-a-strategy-is-initialized-behind-the-scenes","text":"What happens when the strategy object is instantiated eg. strategy = N2SuperTrend() is that the __init__ method inside the N2SuperTrend class is called: class N2SuperTrend ( StrategyBase ): def __init__ ( self , params = {}, config_filepath = USER_CONFIG_PATH ): \"\"\" The first line `super().__init__(params, config_filepath)` means it runs the __init__ method in StrategyBase and inherits its attributes from there, then the name is set. :param params: :type params: :param config_filepath: :type config_filepath: \"\"\" super () . __init__ ( params , config_filepath ) self . name = 'n2_supertrend' This is all you'd need to put in the __init__ of any new strategy, and then put the strategy's logic for how it generates a signal inside of the method YourStrategy.get_signal() Like it says in the comment, the super() function on the first line runs the __init__ of the StrategyBase class so it inherits all the attributes and methods of StrategyBase and then it assigns a name for the strategy. Here's what's happening in StrategyBase.__init__() where the program executes next before coming back to N2SuperTrend : from core.config import Config class StrategyBase ( Config ): \"\"\" A strategy is an object whose main purpose is to contain regularly updated market data by pulling OHLCV data from both the base pair and the quote pair, then combining them to make the synth pair, keeping track of PnL for both underlying trades. The main logic which is specific to your strategy should be implemented in the `get_signal()` method which should then be called at a regular defined interval. The signal can be set either to be for a single timeframe or multiple timeframes by setting the value of `multi_timeframe_signal_mode: Bool` for that strategy. \"\"\" ... def __int__ ( self , params = {}, config_filepath = USER_CONFIG_PATH ): \"\"\" The first line: `super().__init__(params, config_filepath)` means it runs the __init__ method in Config and inherits its attributes from there, then after that, the other attributes are set. :param params: :type params: :param config_filepath: :type config_filepath: :return: :rtype: \"\"\" super () . __init__ ( self , params , config_filepath ) self . name = None self . current_signal = None self . position_manager = PositionManager () The StrategyBase class inherits the Config class and calls the super() function on the first line too, which calls the __init__() of Config . Config doesn't inherit anything and it's a base class for other classes to inherit. It provides an extra layer between the strategy and lower level configuration options eg. [TODO] OHCLV data source should be configurable so that later when making a backtesting environment that will be given historic market data and a much faster tick interval, it will be possible to have multiple instances of running strategies configured differently. It shouldn't need to be edited unless developing/debugging): This is what happens in Config.__init__() where the program executes next before coming back to StrategyBase.__init__() . class Config : __dict__ = { \"exchange\" : str , \"strategy_name\" : str , \"prompt_for_pairs\" : bool , \"base_pair\" : str , \"quote_pair\" : str , \"stake_currency\" : str , \"paper_trade\" : bool , \"debug_mode\" : bool } cfg_parser = ConfigParser () def __init__ ( self , params = {}, filepath = USER_CONFIG_PATH ): \"\"\" **[TODO]**: the API Keys should be read from the config.ini file or given as params then saved in self.exchange_api_keys: dict instead of how I'm currently handling how API keys are accessed which isn't the best way. Then, self.exchange can be initialized taking self.exchange_api_keys as a param. \"\"\" self . params = params if params is None or len ( params ) == 0 : if filepath is not None : self . cfg_parser . read ([ filepath ]) elif filepath is None : raise ValueError try : self . exchange_id = self . cfg_parser [ 'Global Settings' ][ 'exchange' ] self . strategy_name = self . cfg_parser [ 'Global Settings' ][ 'strategy' ] self . strategy_import_path = f \"strategies. { self . strategy_name } \" self . prompt_for_pairs = bool ( self . cfg_parser [ 'Global Settings' ][ 'prompt_for_pairs' ]) self . base_pair = self . cfg_parser [ 'Global Settings' ][ 'base_pair_default' ] self . quote_pair = self . cfg_parser [ 'Global Settings' ][ 'quote_pair_default' ] self . stake_currency = self . cfg_parser [ 'Global Settings' ][ 'stake_currency' ] self . paper_trade = bool ( self . cfg_parser [ 'Global Settings' ][ 'paper_trade' ]) # self.synth_pair = self.get_synth_pair_symbol(self.base_pair, self.quote_pair) # self.strategy = importlib.import_module(f\"strategies.{self.strategy_name}\") # self.exchange: ccxt.Exchange = self.enabled_exchanges[self.cfg_file_key] except : raise ValueError ( \"Failed to read from config (Make sure all values are assigned)\" ) elif self . params is not None : for param in self . params : if param not in self . __dict__ : raise ValueError ( f \"Invalid Parameter: ' { param } '\" ) try : self . exchange_id : str = self . params [ 'exchange' ] self . strategy_name = self . params [ 'strategy' ] self . strategy_import_path = f \"strategies. { self . strategy_name [ 'strategy' ] } \" self . prompt_for_pairs : bool = params [ 'prompt_for_pairs' ], self . base_pair : str = params [ 'base_pair' ], self . quote_pair : str = params [ 'quote_pair' ], self . stake_currency : str = params [ 'stake_currency' ] self . paper_trade : bool = params [ 'paper_trade' ] # self.strategy = importlib.import_module(f\"strategies.{self.strategy_name}\") # self.exchange: ccxt.Exchange = self.enabled_exchanges[self.cfg_file_key] except : raise ValueError ( \"Params incomplete\" ) else : raise Exception ( \"Cannot Initialize Config() without either params or config_filepath\" ) self . synth_pair = utils . get_synth_pair_tuple ( self . base_pair , self . quote_pair ) self . enabled_exchanges = self . get_enabled_exchanges () self . exchange : ccxt . Exchange = self . enabled_exchanges [ self . exchange_id . lower ()] What it's doing is checking to see if params were supplied to override the default config. If params are passed to Config or any of its subclasses ie. StrategyBase or N2SuperTrend are instantiated, then it will load those params as a configuration. If params are not supplied, it will use a config.ini file specified by filepath , which defaults to the global constant USER_CONFIG_PATH (This is set in core.constants to user/user-config.ini )","title":"2.2 How a strategy is initialized behind the scenes:"},{"location":"How_it_works/#31-after-strategy-is-initialized","text":"It will have its own ccxt.Exchange type initialized with api keys read from the user config and PositionManager object as a Fields and which can be accessed from inside or outside of the strategy class (better inside):","title":"3.1 After strategy is initialized:"},{"location":"How_it_works/#going-back-to-the-run_bot-function-in-mainpy","text":"def run_bot ( strategy = N2SuperTrend ()): running = True pm : PositionManager = strategy . position_manager while running : if strategy . debug_mode : \"\"\"If in debug mode, prompt for signal override\"\"\" override_signal = input ( \"[DEBUG]Enter a signal to emulate: ([LONG]|SHORT|CLOSE)\" ) if override_signal == \"\" : signal = 'LONG' # Default if you just press enter at the prompt elif override_signal . upper () == 'SHORT' or override_signal == 'LONG' : signal = override_signal else : \"\"\"If not in debug mode, call the get_signal method of the strategy\"\"\" signal = strategy . listen_for_signals () ... if __name__ == '__main__' : run_bot () # Can pass a Strategy to override default eg. main(strategy=YourStrategy) First, the strategy's PositionManager is assigned to the variable pm (can be called anything) Then, it enters a while loop: while running: This while loop is essentially one tick, and it would be better to move this out of __main__.py and into a a new method of StrategyBase or Config : called run() or start() The I haven't yet accounted for rate limits, but it's possible to fetch rate limits for an exchange with ccxt.","title":"Going back to the run_bot() function in main.py:"},{"location":"How_it_works/#32-getting-a-signal-from-the-strategy","text":"When the strategy.get_signal method is called, it will run whatever logic you have defined in that method for your strategy. If you don't create a method in your strategy called get_signal , it will default to the one in StrategyBase and raise a NotImplemented error: Otherwise, when you do define a get_signal method, it will override the one in StrategyBase and you can implement whatever logic and conditions to generate the strategy's net signal in that method. The signal can either based on one timeframe or you can enable and define Multi-timeframe signal rules as a dict with keys for each timeframe that have bool values. Whichever timeframes are set to true, must reach a consensus of their signals for them to generate an aggregated signal. [TODO] : make it so that in multi-timeframe mode, instead of fetching signals for all timeframes at every tick, they will each have different intervals to stay within rate limits. I also need to change how get_signal is currently fetching historic bars every time it's called when it should only need to do that once, and then update the price with live tick data from by using ccxt.Exchange.fetch_ticker() def run_bot ( strategy = N2SuperTrend ()): running = True pm : PositionManager = strategy . position_manager while running : ... signal = strategy . listen_for_signals () if signal is not None and signal != 'CLOSE' : \"\"\"If there is a new signal to LONG or SHORT:\"\"\" if pm . get_current_position () is None : \"\"\" If there's no current position open, then open one in the signal of the signal and set it as pm's current_position \"\"\" position = Position ( strategy . base_pair , strategy . quote_pair , direction = signal , order_type = 'limit' ) . open () # TODO: Here is where the `core.notifier` class would be # used to report the opening of the position and send # send a notification via telegram and/or email. pm . set_current_position ( position ) elif signal == 'CLOSE' : \"\"\" If the signal is 'CLOSE', then close the pm.current_position \"\"\" pm . current_position . close () # TODO: Here `core.notifier` would be used again to report # the closing of the trade and send via email/telegram tick_interval = 60 # This should be adjusted to take API rate limits into account \"\"\"For now the tick_interval is set here, but it should be set by params config file by Config.__init__()\"\"\" time . sleep ( tick_interval ) # await asyncio.sleep(tick_interval)","title":"3.2 Getting a signal from the strategy"},{"location":"How_it_works/#4-opening-a-position","text":"","title":"4. Opening a Position:"},{"location":"How_it_works/#5-closing-a-position","text":"","title":"5. Closing a position:"},{"location":"How_it_works/#6-generating-report-notifications","text":"","title":"6. Generating report notifications:"},{"location":"How_it_works/#7-further-ideas","text":"7.1 Saving reports to a database? 7.2 Backtesting engine 7.2.1 This should be done in a lower level language eg. Cython which is python compiled into .pyx / .pyd C-like modules with python syntax that can be accessed as normal modules but run compiled machine code is run instead of having a runtime interperet the script. Cython is also what Hummingbot uses for calculation-intensive modules. 7.3 Combine with triangular arbitrage strategy, using any exposed coins in an open position as stake currencies that execute arbitrage signals and be returned back to the same coin to resume the position 7.4 Add support for normal trading pairs, not just combined trading pairs","title":"7. Further ideas:"},{"location":"further_ideas/","text":"Further ideas: Saving reports to a database? Backtesting engine This should be done in a lower level language eg. Cython which is python compiled into .pyx / .pyd C-like modules with python syntax that can be accessed as normal modules but run compiled machine code is run instead of having a runtime interperet the script. Cython is also what Hummingbot uses for calculation-intensive modules. Combine with triangular arbitrage strategy by using any exposed coins in an open position as stake currencies which execute arbitrage signals and are then returned back to the same coin to resume the position. Add support for normal trading pairs, not just combined trading pairs Add support for all tradingview indicators via web scraping or api Add support for MetaTrader indicators via a ZeroMQ Bridge","title":"Further Ideas"},{"location":"further_ideas/#further-ideas","text":"Saving reports to a database? Backtesting engine This should be done in a lower level language eg. Cython which is python compiled into .pyx / .pyd C-like modules with python syntax that can be accessed as normal modules but run compiled machine code is run instead of having a runtime interperet the script. Cython is also what Hummingbot uses for calculation-intensive modules. Combine with triangular arbitrage strategy by using any exposed coins in an open position as stake currencies which execute arbitrage signals and are then returned back to the same coin to resume the position. Add support for normal trading pairs, not just combined trading pairs Add support for all tradingview indicators via web scraping or api Add support for MetaTrader indicators via a ZeroMQ Bridge","title":"Further ideas:"},{"location":"message-for-noe/","text":"Okay so it's difficult to know where to begin but I'll make an outline of things I think are important to communicate: I'll start with an honest self-assessment as a developer: fa-lg fa-2x fa-3x fa-4x fa-5x i <3 :fa-coffee: and I <3 :fa-beer: and I'll buy wayland ten of both. Strengths: Good problem solver. I approach problems methodically in a way that I imagine a senior developer would, and each time I get stuck, I get unstuck: Good at stepping through & debugging python code. Even if I don't understand something at first, I will step through each line of code as it executes to understand what is happening, and eventually figure out the source of whatever challenge I'm currently facing. Track the time I spend coding with WakaTime, and I also track the time I spend learning instead of building and I don't require that you pay for the learning. Since I am still learning, I think the per-project payment model is more fair instead of per-hour, because I can deliver the same results as a senior developer but it may take me more time than a senior developer. I document my code, and provide commentary on my thought & decision processes. You can see an example of that here (unfinished & outdated as it's my current project): http://5.180.183.48/ I know PlantUML for creating activity diagrams & other useful graphics like class/object diagrams I first started learning to code more than 12 years ago Committed. I don't give up even when I get stuck or frustrated I find your project genuinely interesting Good at judging whether or not I'm capable of doing something, and able to describe problems in an easy to understand way, and think of new solutions Weaknesses. Even though I started learning to code 12 years ago, it was very on and off and I never truly started to take it seriously until this year, 2022, and I feel like I've finally reached a new level where I know that if I just spend enough time and focus on a problem that I'm capable of solving it. Even though I know some advanced programming concepts & paradigms implemented in python since that's the language I've spent the most time with, it would take me time to learn their equivilent implementations in JS (But I can do it) I'm not very good at estimating how long something takes to build, even when I know I can do it.","title":"Message for noe"},{"location":"message-for-noe/#strengths","text":"Good problem solver. I approach problems methodically in a way that I imagine a senior developer would, and each time I get stuck, I get unstuck: Good at stepping through & debugging python code. Even if I don't understand something at first, I will step through each line of code as it executes to understand what is happening, and eventually figure out the source of whatever challenge I'm currently facing. Track the time I spend coding with WakaTime, and I also track the time I spend learning instead of building and I don't require that you pay for the learning. Since I am still learning, I think the per-project payment model is more fair instead of per-hour, because I can deliver the same results as a senior developer but it may take me more time than a senior developer. I document my code, and provide commentary on my thought & decision processes. You can see an example of that here (unfinished & outdated as it's my current project): http://5.180.183.48/ I know PlantUML for creating activity diagrams & other useful graphics like class/object diagrams I first started learning to code more than 12 years ago Committed. I don't give up even when I get stuck or frustrated I find your project genuinely interesting Good at judging whether or not I'm capable of doing something, and able to describe problems in an easy to understand way, and think of new solutions","title":"Strengths:"},{"location":"message-for-noe/#weaknesses","text":"Even though I started learning to code 12 years ago, it was very on and off and I never truly started to take it seriously until this year, 2022, and I feel like I've finally reached a new level where I know that if I just spend enough time and focus on a problem that I'm capable of solving it. Even though I know some advanced programming concepts & paradigms implemented in python since that's the language I've spent the most time with, it would take me time to learn their equivilent implementations in JS (But I can do it) I'm not very good at estimating how long something takes to build, even when I know I can do it.","title":"Weaknesses."},{"location":"Docstrings/","text":"Source Code Documentation for Developers Important Most of these pages are generated automatically from the docstring comments in the source code using a tool called mkdocstrings. Any pages dedicated to a specific .py file will be populated with the docstrings written in that file once I get that working. For now, it's just a skeleton directory structure.","title":"Source Code Documentation for Developers"},{"location":"Docstrings/#source-code-documentation-for-developers","text":"Important Most of these pages are generated automatically from the docstring comments in the source code using a tool called mkdocstrings. Any pages dedicated to a specific .py file will be populated with the docstrings written in that file once I get that working. For now, it's just a skeleton directory structure.","title":"Source Code Documentation for Developers"},{"location":"Docstrings/__main__.py/","text":"","title":"  main  .py"},{"location":"Docstrings/dev_scripts/","text":"","title":"Dev scripts"},{"location":"Docstrings/mkdocs.yml/","text":"","title":"Mkdocs.yml"},{"location":"Docstrings/requirements.txt/","text":"","title":"Requirements.txt"},{"location":"Docstrings/requirements_dev.txt/","text":"","title":"Requirements dev.txt"},{"location":"Docstrings/core/__init__/","text":"init This is a file required by python for imports to work properly","title":"__init__"},{"location":"Docstrings/core/__init__/#init","text":"This is a file required by python for imports to work properly","title":"init"},{"location":"Docstrings/core/config/","text":"core.config src: '/core/config.py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"***core.config***"},{"location":"Docstrings/core/config/#coreconfig","text":"src: '/core/config.py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"core.config"},{"location":"Docstrings/core/constants/","text":"core.constants src: '/core/constants.py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"***core.constants***"},{"location":"Docstrings/core/constants/#coreconstants","text":"src: '/core/constants.py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"core.constants"},{"location":"Docstrings/core/core/","text":"core module","title":"core module"},{"location":"Docstrings/core/core/#core-module","text":"","title":"core module"},{"location":"Docstrings/core/indicators/","text":"core.indicators src: '/core/indicators.py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"***core.indicators***"},{"location":"Docstrings/core/indicators/#coreindicators","text":"src: '/core/indicators.py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"core.indicators"},{"location":"Docstrings/core/notifier/","text":"core.notifier src: '/core/notifier.py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"***core.notifier***"},{"location":"Docstrings/core/notifier/#corenotifier","text":"src: '/core/notifier.py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"core.notifier"},{"location":"Docstrings/core/position_manager/","text":"core.position_manager src: '/core/position_manager.py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page.","title":"***core.position_manager***"},{"location":"Docstrings/core/position_manager/#coreposition_manager","text":"src: '/core/position_manager.py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page.","title":"core.position_manager"},{"location":"Docstrings/core/utils/","text":"core.utils src: '/core/utils.py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"***core.utils***"},{"location":"Docstrings/core/utils/#coreutils","text":"src: '/core/utils.py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"core.utils"},{"location":"Docstrings/core/exchanges/kucoin_extended/","text":"","title":"Kucoin extended"},{"location":"Docstrings/strategies/__init__/","text":"","title":"  init  "},{"location":"Docstrings/strategies/n2_supertrend/","text":"strategies.n2_supertrend src: '/strategies/n2_supertrend .py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"***strategies.n2_supertrend***"},{"location":"Docstrings/strategies/n2_supertrend/#strategiesn2_supertrend","text":"src: '/strategies/n2_supertrend .py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"strategies.n2_supertrend"},{"location":"Docstrings/strategies/strategies/","text":"strategies","title":"strategies"},{"location":"Docstrings/strategies/strategies/#strategies","text":"","title":"strategies"},{"location":"Docstrings/strategies/strategy_base/","text":"strategies.strategy_base src: '/strategies/strategy_base .py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"***strategies.strategy_base***"},{"location":"Docstrings/strategies/strategy_base/#strategiesstrategy_base","text":"src: '/strategies/strategy_base .py' Warning This file isn't properly commented but I'll do that and an in-depth explanation will exist on this page. :: stub","title":"strategies.strategy_base"},{"location":"Docstrings/user/config-template.ini/","text":"","title":"Config template.ini"},{"location":"Docstrings/user/user-config.ini/","text":"","title":"User config.ini"},{"location":"Docstrings/user/user/","text":"user","title":"user"},{"location":"Docstrings/user/user/#user","text":"","title":"user"},{"location":"Releases/dev_v0.0.1/dev-journal/","text":"v0.0.1 (Development Release) Important This failed the github checks because of a markdown extension for the documentation, so I made another release v0.0.2-dev to fix that. Todo Publish the release on the Github repo Github release viewable here Come back and add some more information here describing how the steps below are implemented including: a PlantUML class diagram of each of the classes: Config PositionManager Position Notifier StrategyBase N2SuperTrend An activity diagram depicting the strategy N2SuperTrend (Right click the image and open in a new tab to see full-size): Done 1. Write a script which scrapes the contents of what the describe() method returns. This was necessary to avoid having to import every exchange to be able to get this information which I was trying to do before with many issues. 2. Fix imports in core.constants for the scraped data to not give any errors when saved as a python dict. For now I only need the content of rateLimit requiredCredentials and has which don't have any out of scope variable names like the rest of the errors, so I can ommit the rest for now and focus on getting those two working first, then sort out the imports after. Having every exchange's requiredCredentials as a constant helps in the Config & StrategyBase classes where the exchange isn't yet imported or initialized but I still need to know what those credentials need to be Having every exchange's has as a constant will make it very easy to see which exchanges support what, and be able to judge which strategies are suitable for which exchanges. eg. which exchanges already support margin trading and fetchBorrowRate etc 3. Make a list of all ccxt exchanges which have: margin trading fetchBorrowRate NOTE: You can view this info & more by looking at the 'CCXT Insights' section of the docs 4. Fully implement each step of Long/Short positions including borrowing. [4.1] open_long: Step 1: Query exchange to fetch max borrow quantity of borrow_coin. borrow_coin will be the base coin of the quote pair e.g. in ETHUSDT/ BTC USDT it is BTC Step 2: If prompt_borrow is true, print the max borrow amount retrieved in step 1, then prompt the user to either accept the max amount or instead enter an amount. Step 3: Borrow from the exchange in the desired quantity Step 4: Sell quote pair using the coins borrowed in step 3. eg. Sell BTC for USDT Step 5: Buy the base coin of the base pair using the quote coin of the base pair. eg. Buy ETH with USDT [4.2] open_short: Copy & modify steps from open_long (refactor this later) borrow_coin will be the base coin of the base pair e.g. in ETH USDT/BTCUSDT it is ETH [4.3] close: Re-pay loan Sell assets back to stake currency USDT This will only work properly when event handling is implemented, and when it is, it'll also be very simple to add the notifications 5. Implement Telegram Notifications with telethon Note: I did this in my last project so I can just copy/paste that Dev Log: Note (March 26th, 2022) [21:30 CET | 18:30 EDT] To make managing positions dynamic, it needs to have a 'newSignal' event which, when fired will call PositionManager.open(), or PositionManager.close(), so that a signal can come at any time. Implementing this will also make notifications much simpler. I've worked briefly with event handling in C# but I have to admit this is making my head spin. I think I have a handle on it (no pun intended), and I've got a jupyter notebook in dev_scripts/dev_EventHandling.ipynb where I'm figuring out how to get it to work properly. Once it works in the notebook, I'll do the same in the real classes and add the notifications. At that point the MVP will be finished and ready to submit. (March 25th, 2022) [22:34 CET | 19:31 EDT] This is already partially usable. At the very least, you can see it open long or short positions, and now I'm just making it save more metadata which will be used to close each position. Once that works, the telegram bot will just send the contents of either pm.current_position.status or pm.current_position.borrow_info & pm.current_position.trade_info . If you want to test this out, then I'd recommend doing so on KuCoin's sandbox exchange which works the same as the normal exchange but without real funds. Right now the bot is using the sandbox API urls/endpoints, so to try it on the real exchange you'd need to delete lines 34-39 from core/exchanges/kucoin_extended.py (March 24th, 2022) [16:31 CET | 11:31 EDT] Now each step in open_long works. So next I will do (almost) the same thing for open_short, then move onto close & send notification. (March 23rd, 2022) [20:21 CET | 17:37 EDT] Success I thought that after borrowing, I'd be able to use normal trades, but KuCoin's API is different for trading with the regular trading account and the margin account, so I am adding a new method for posting a margin order which you can see here Right now I'm I was getting this error as a response from KuCoin: {'code': '200000', 'msg': 'position internal error'} I'm working on figuring it out I figured it out , and I've also posted an issue in the ccxt repo. I was calling the API incorrectly, but also it seems a bug on their end didn't give the correct error code. (March 23rd, 2022) [07:37am CET | 03:37am EDT] So I didn't manage to get it finished on Wednesday since yet again I mis-judged how long it would take. However, I have made loads of progress since then and it's looking quite promising. Getting closer to the finish line, since I already managed to properly extend ccxt.kucoin and added 2 new methods to it: fetchMaxBorrowSize and borrow which work properly. Actually making trades is simple compared to that, since it's already built in and it won't be difficult to figure out how to get ccxt to do that like it was with the margin-related stuff I've been using KuCoin's sandbox exchange for testing which works the same way as the real one. Once open_long works, then I can just copy, paste & tweak it for open_short Then I'll add a close method which closes the position & repays the loan If you want to see how it's working, you can open the program in an IDE with a debugger, and just watch self.status . I will walk you through that when it's submitted. (March 21st, 2022) [11:08am CET | 06:08am EDT] Like I said last night, I'm trying to get this functional by the end of today. Since our last message, I've managed to get through steps 2 & 3 which is going to help a lot with step 4. (March 20th, 2022) Hi Nico, this is my first update in a couple of days since I got stuck on a problem which I've just recently (mostly) solved. I will explain that below. I've also migrated the TODO list to here for now while I'm developing this, but after the first release I will migrate the TODO to its own page, and this will be the Index/Home.","title":"v0.0.1-dev"},{"location":"Releases/dev_v0.0.1/dev-journal/#v001-development-release","text":"Important This failed the github checks because of a markdown extension for the documentation, so I made another release v0.0.2-dev to fix that. Todo Publish the release on the Github repo Github release viewable here Come back and add some more information here describing how the steps below are implemented including: a PlantUML class diagram of each of the classes: Config PositionManager Position Notifier StrategyBase N2SuperTrend An activity diagram depicting the strategy N2SuperTrend (Right click the image and open in a new tab to see full-size): Done 1. Write a script which scrapes the contents of what the describe() method returns. This was necessary to avoid having to import every exchange to be able to get this information which I was trying to do before with many issues. 2. Fix imports in core.constants for the scraped data to not give any errors when saved as a python dict. For now I only need the content of rateLimit requiredCredentials and has which don't have any out of scope variable names like the rest of the errors, so I can ommit the rest for now and focus on getting those two working first, then sort out the imports after. Having every exchange's requiredCredentials as a constant helps in the Config & StrategyBase classes where the exchange isn't yet imported or initialized but I still need to know what those credentials need to be Having every exchange's has as a constant will make it very easy to see which exchanges support what, and be able to judge which strategies are suitable for which exchanges. eg. which exchanges already support margin trading and fetchBorrowRate etc 3. Make a list of all ccxt exchanges which have: margin trading fetchBorrowRate NOTE: You can view this info & more by looking at the 'CCXT Insights' section of the docs 4. Fully implement each step of Long/Short positions including borrowing. [4.1] open_long: Step 1: Query exchange to fetch max borrow quantity of borrow_coin. borrow_coin will be the base coin of the quote pair e.g. in ETHUSDT/ BTC USDT it is BTC Step 2: If prompt_borrow is true, print the max borrow amount retrieved in step 1, then prompt the user to either accept the max amount or instead enter an amount. Step 3: Borrow from the exchange in the desired quantity Step 4: Sell quote pair using the coins borrowed in step 3. eg. Sell BTC for USDT Step 5: Buy the base coin of the base pair using the quote coin of the base pair. eg. Buy ETH with USDT [4.2] open_short: Copy & modify steps from open_long (refactor this later) borrow_coin will be the base coin of the base pair e.g. in ETH USDT/BTCUSDT it is ETH [4.3] close: Re-pay loan Sell assets back to stake currency USDT This will only work properly when event handling is implemented, and when it is, it'll also be very simple to add the notifications 5. Implement Telegram Notifications with telethon Note: I did this in my last project so I can just copy/paste that","title":"v0.0.1 (Development Release)"},{"location":"Releases/dev_v0.0.1/dev-journal/#dev-log","text":"Note (March 26th, 2022) [21:30 CET | 18:30 EDT] To make managing positions dynamic, it needs to have a 'newSignal' event which, when fired will call PositionManager.open(), or PositionManager.close(), so that a signal can come at any time. Implementing this will also make notifications much simpler. I've worked briefly with event handling in C# but I have to admit this is making my head spin. I think I have a handle on it (no pun intended), and I've got a jupyter notebook in dev_scripts/dev_EventHandling.ipynb where I'm figuring out how to get it to work properly. Once it works in the notebook, I'll do the same in the real classes and add the notifications. At that point the MVP will be finished and ready to submit. (March 25th, 2022) [22:34 CET | 19:31 EDT] This is already partially usable. At the very least, you can see it open long or short positions, and now I'm just making it save more metadata which will be used to close each position. Once that works, the telegram bot will just send the contents of either pm.current_position.status or pm.current_position.borrow_info & pm.current_position.trade_info . If you want to test this out, then I'd recommend doing so on KuCoin's sandbox exchange which works the same as the normal exchange but without real funds. Right now the bot is using the sandbox API urls/endpoints, so to try it on the real exchange you'd need to delete lines 34-39 from core/exchanges/kucoin_extended.py (March 24th, 2022) [16:31 CET | 11:31 EDT] Now each step in open_long works. So next I will do (almost) the same thing for open_short, then move onto close & send notification. (March 23rd, 2022) [20:21 CET | 17:37 EDT] Success I thought that after borrowing, I'd be able to use normal trades, but KuCoin's API is different for trading with the regular trading account and the margin account, so I am adding a new method for posting a margin order which you can see here Right now I'm I was getting this error as a response from KuCoin: {'code': '200000', 'msg': 'position internal error'} I'm working on figuring it out I figured it out , and I've also posted an issue in the ccxt repo. I was calling the API incorrectly, but also it seems a bug on their end didn't give the correct error code. (March 23rd, 2022) [07:37am CET | 03:37am EDT] So I didn't manage to get it finished on Wednesday since yet again I mis-judged how long it would take. However, I have made loads of progress since then and it's looking quite promising. Getting closer to the finish line, since I already managed to properly extend ccxt.kucoin and added 2 new methods to it: fetchMaxBorrowSize and borrow which work properly. Actually making trades is simple compared to that, since it's already built in and it won't be difficult to figure out how to get ccxt to do that like it was with the margin-related stuff I've been using KuCoin's sandbox exchange for testing which works the same way as the real one. Once open_long works, then I can just copy, paste & tweak it for open_short Then I'll add a close method which closes the position & repays the loan If you want to see how it's working, you can open the program in an IDE with a debugger, and just watch self.status . I will walk you through that when it's submitted. (March 21st, 2022) [11:08am CET | 06:08am EDT] Like I said last night, I'm trying to get this functional by the end of today. Since our last message, I've managed to get through steps 2 & 3 which is going to help a lot with step 4. (March 20th, 2022) Hi Nico, this is my first update in a couple of days since I got stuck on a problem which I've just recently (mostly) solved. I will explain that below. I've also migrated the TODO list to here for now while I'm developing this, but after the first release I will migrate the TODO to its own page, and this will be the Index/Home.","title":"Dev Log:"},{"location":"Releases/dev_v0.0.2/dev-journal/","text":"v0.0.2 (Development Release) Info This is just the same as v0.0.1-dev except I removed the markdown extension that caused a gh-deploy error and it's passing now Done Publish the release on the Github repo Github release viewable here","title":"v0.0.2-dev"},{"location":"Releases/dev_v0.0.2/dev-journal/#v002-development-release","text":"Info This is just the same as v0.0.1-dev except I removed the markdown extension that caused a gh-deploy error and it's passing now Done Publish the release on the Github repo Github release viewable here","title":"v0.0.2 (Development Release)"},{"location":"Releases/stable_v0.1.0/dev-journal/","text":"v0.1.0 (stable & unit tested) Todo Make sure limit orders price='@best' is working properly, which fetches the order book for the best asks/bids, then creates a limit order at the current best price (For it to be real-time, it needs to be done via websocket which is only part of the ccxt pro apparently which is going to become free later this year. I can also however implement that myself. For now, I've managed to get the order book from the REST API, but so far I haven't been able to get real-time data from that [REST API] fetch best bids/asks? (if it's possible) Implement Websockets connection & fetch best 5 bids/asks as written in KuCoin's documentation Ensure every method has debug status prints for when debug_mode is enabled Ensure all queries are within the rate limits as they vary for different API endpoints Log the status and save into a file Try different configurations and check the logs for any errors/exceptions, then fix them Write unit test cases Do any debugging required for the unit tests to all pass Write CLI setup wizard which guides the user through setting up a configuration/strategy (maybe also a password) Add email notifications Release Stable v0.1.0 Create Sequence Diagram for the entire program execution (examples below taken from mermaid & PlantText )","title":"v0.1.0 (stable & unit tested)"},{"location":"Releases/stable_v0.1.0/dev-journal/#v010-stable-unit-tested","text":"Todo Make sure limit orders price='@best' is working properly, which fetches the order book for the best asks/bids, then creates a limit order at the current best price (For it to be real-time, it needs to be done via websocket which is only part of the ccxt pro apparently which is going to become free later this year. I can also however implement that myself. For now, I've managed to get the order book from the REST API, but so far I haven't been able to get real-time data from that [REST API] fetch best bids/asks? (if it's possible) Implement Websockets connection & fetch best 5 bids/asks as written in KuCoin's documentation Ensure every method has debug status prints for when debug_mode is enabled Ensure all queries are within the rate limits as they vary for different API endpoints Log the status and save into a file Try different configurations and check the logs for any errors/exceptions, then fix them Write unit test cases Do any debugging required for the unit tests to all pass Write CLI setup wizard which guides the user through setting up a configuration/strategy (maybe also a password) Add email notifications Release Stable v0.1.0 Create Sequence Diagram for the entire program execution (examples below taken from mermaid & PlantText )","title":"v0.1.0 (stable &amp; unit tested)"},{"location":"ccxt_insights/1_overview/","text":"CCXT Insights: Overview Info Now that I've generated the EXCHANGES constant, I can mine some useful data from that. Here's an overview of the data which I thought was relevant in finding suitable exchanges. Each column represents keys from the dict that's returned by each exchange's describe() method. The bool values represent whether the keys are present or not for each exchange. You can click on each column to sort them. On the next page I will filter these results. EXCHANGE requiredCredentials rateLimit has margin fetchBorrowRate 0 COINSPOT False True True False False 1 HITBTC False True True False False 2 RIPIO True True True False False 3 BITFLYER False True True False 4 BUDA False True True False False 5 KUNA False True True 6 BINANCEUSDM False False False 7 BITMART True True True 8 UPBIT False True True 9 WAVESEXCHANGE False True True False False 10 OCEANEX False True True False False 11 TIDEBIT False True True False False 12 BITVAVO True True True False False 13 MEXC False True True 14 BITGET True True True False False 15 COINBASEPRIME False False False False False 16 BINANCEUS False False False False False 17 THEROCK False True True 18 EQONEX True True True False False 19 ZB False True True True True 20 STEX True True True False False 21 XENA False True True False False 22 WHITEBIT False True True 23 EXMO False True True 24 BIGONE False True True 25 HITBTC3 False True True 26 EQUOS False False False 27 BITHUMB False True True False False 28 BL3P False True True False False 29 BITMEX False True True False 30 INDODAX False True True False False 31 COINFALCON False True True False False 32 LATOKEN False True True False False 33 OKCOIN True True True 34 BINANCE False True True True True 35 COINMATE True True True False False 36 BITFOREX False True True False False 37 HUOBIJP False True True 38 BTCBOX False True True False False 39 BITTREX False True True False False 40 KUCOIN True True True False 41 BTCMARKETS False True True False False 42 GATEIO True True True True False 43 LBANK False False True False False 44 BITBNS False True True 45 GEMINI False True True False False 46 HUOBI False True True True True 47 BTCALPHA False False True False False 48 COINONE True True True False False 49 HOLLAEX True True True False 50 BW True True True 51 QTRADE False True True False False 52 WOO False True True True 53 TIDEX False True True False False 54 AAX False True True False False 55 ASCENDEX False True True 56 ZIPMEX False False False 57 ZONDA False True True False False 58 PHEMEX True True True False False 59 OKEX5 False False False False False 60 KRAKEN False True True True False 61 OKX True True True True True 62 ZAIF False True True 63 MERCADO False True True False False 64 FTX False True True True True 65 BEQUANT False False False True True 66 KUCOINFUTURES True True True False False 67 LIQUID False True True 68 TIMEX False True True False False 69 BITBANK False False True False False 70 COINBASE True True True False False 71 NOVADAX True True True False False 72 DERIBIT False True True False False 73 ITBIT False True True False False 74 PROBIT True True True False False 75 OKEX False False False False False 76 BITBAY False False False False False 77 BTCTURK False True True False False 78 COINCHECK False True True False False 79 BITSTAMP1 True True True False False 80 WAZIRX False True True 81 BITRUE False True True False False 82 BTCTRADEUA False True True False False 83 BINANCECOINM False False False False False 84 YOBIT False True True False False 85 DELTA True True True 86 BITFINEX2 False True True 87 FTXUS False False True 88 CREX24 False True True False False 89 FLOWBTC False True False False False 90 CURRENCYCOM False True True True 91 BITSO False True True False False 92 BITSTAMP True True True False False 93 LUNO False True True False False 94 CEX True True True 95 INDEPENDENTRESERVE False True True False False 96 BITCOINCOM False False False False False 97 BYBIT False True True False False 98 CRYPTOCOM False True True 99 HUOBIPRO False False False 100 COINEX False True True 101 COINBASEPRO True True True 102 BLOCKCHAINCOM True True True 103 BYTETRADE False True True False False 104 VCC False True True False False 105 BITFINEX False True True 106 BIT2C False True True False False 107 BIBOX False False True False 108 CDAX False True True 109 FMFWIO False False False 110 DIGIFINEX False True True 111 IDEX True True True False False 112 INIT False False False False False 113 PAYMIUM False True True 114 POLONIEX False True True 115 BITPANDA True True True False False 116 NDAX True True True False False 117 LYKKE True True True False False","title":"CCXT Insights: Overview"},{"location":"ccxt_insights/1_overview/#ccxt-insights-overview","text":"Info Now that I've generated the EXCHANGES constant, I can mine some useful data from that. Here's an overview of the data which I thought was relevant in finding suitable exchanges. Each column represents keys from the dict that's returned by each exchange's describe() method. The bool values represent whether the keys are present or not for each exchange. You can click on each column to sort them. On the next page I will filter these results. EXCHANGE requiredCredentials rateLimit has margin fetchBorrowRate 0 COINSPOT False True True False False 1 HITBTC False True True False False 2 RIPIO True True True False False 3 BITFLYER False True True False 4 BUDA False True True False False 5 KUNA False True True 6 BINANCEUSDM False False False 7 BITMART True True True 8 UPBIT False True True 9 WAVESEXCHANGE False True True False False 10 OCEANEX False True True False False 11 TIDEBIT False True True False False 12 BITVAVO True True True False False 13 MEXC False True True 14 BITGET True True True False False 15 COINBASEPRIME False False False False False 16 BINANCEUS False False False False False 17 THEROCK False True True 18 EQONEX True True True False False 19 ZB False True True True True 20 STEX True True True False False 21 XENA False True True False False 22 WHITEBIT False True True 23 EXMO False True True 24 BIGONE False True True 25 HITBTC3 False True True 26 EQUOS False False False 27 BITHUMB False True True False False 28 BL3P False True True False False 29 BITMEX False True True False 30 INDODAX False True True False False 31 COINFALCON False True True False False 32 LATOKEN False True True False False 33 OKCOIN True True True 34 BINANCE False True True True True 35 COINMATE True True True False False 36 BITFOREX False True True False False 37 HUOBIJP False True True 38 BTCBOX False True True False False 39 BITTREX False True True False False 40 KUCOIN True True True False 41 BTCMARKETS False True True False False 42 GATEIO True True True True False 43 LBANK False False True False False 44 BITBNS False True True 45 GEMINI False True True False False 46 HUOBI False True True True True 47 BTCALPHA False False True False False 48 COINONE True True True False False 49 HOLLAEX True True True False 50 BW True True True 51 QTRADE False True True False False 52 WOO False True True True 53 TIDEX False True True False False 54 AAX False True True False False 55 ASCENDEX False True True 56 ZIPMEX False False False 57 ZONDA False True True False False 58 PHEMEX True True True False False 59 OKEX5 False False False False False 60 KRAKEN False True True True False 61 OKX True True True True True 62 ZAIF False True True 63 MERCADO False True True False False 64 FTX False True True True True 65 BEQUANT False False False True True 66 KUCOINFUTURES True True True False False 67 LIQUID False True True 68 TIMEX False True True False False 69 BITBANK False False True False False 70 COINBASE True True True False False 71 NOVADAX True True True False False 72 DERIBIT False True True False False 73 ITBIT False True True False False 74 PROBIT True True True False False 75 OKEX False False False False False 76 BITBAY False False False False False 77 BTCTURK False True True False False 78 COINCHECK False True True False False 79 BITSTAMP1 True True True False False 80 WAZIRX False True True 81 BITRUE False True True False False 82 BTCTRADEUA False True True False False 83 BINANCECOINM False False False False False 84 YOBIT False True True False False 85 DELTA True True True 86 BITFINEX2 False True True 87 FTXUS False False True 88 CREX24 False True True False False 89 FLOWBTC False True False False False 90 CURRENCYCOM False True True True 91 BITSO False True True False False 92 BITSTAMP True True True False False 93 LUNO False True True False False 94 CEX True True True 95 INDEPENDENTRESERVE False True True False False 96 BITCOINCOM False False False False False 97 BYBIT False True True False False 98 CRYPTOCOM False True True 99 HUOBIPRO False False False 100 COINEX False True True 101 COINBASEPRO True True True 102 BLOCKCHAINCOM True True True 103 BYTETRADE False True True False False 104 VCC False True True False False 105 BITFINEX False True True 106 BIT2C False True True False False 107 BIBOX False False True False 108 CDAX False True True 109 FMFWIO False False False 110 DIGIFINEX False True True 111 IDEX True True True False False 112 INIT False False False False False 113 PAYMIUM False True True 114 POLONIEX False True True 115 BITPANDA True True True False False 116 NDAX True True True False False 117 LYKKE True True True False False","title":"CCXT Insights: Overview"},{"location":"ccxt_insights/2_exchanges_with_margin/","text":"EXCHANGE requiredCredentials rateLimit has margin fetchBorrowRate 19 ZB False True True True True 34 BINANCE False True True True True 42 GATEIO True True True True False 46 HUOBI False True True True True 52 WOO False True True True 60 KRAKEN False True True True False 61 OKX True True True True True 64 FTX False True True True True 65 BEQUANT False False False True True 90 CURRENCYCOM False True True True","title":"Exchanges with margin"},{"location":"ccxt_insights/3_exchanges_with_fetchBorrowRate/","text":"EXCHANGE requiredCredentials rateLimit has margin fetchBorrowRate 19 ZB False True True True True 34 BINANCE False True True True True 46 HUOBI False True True True True 61 OKX True True True True True 64 FTX False True True True True 65 BEQUANT False False False True True","title":"Exchanges with fetchBorrowRate"},{"location":"ccxt_insights/ccxt-insights-1/","text":"EXCHANGE requiredCredentials rateLimit has margin fetchBorrowRate 0 COINSPOT False True True False False 1 HITBTC False True True False False 2 RIPIO True True True False False 3 BITFLYER False True True False 4 BUDA False True True False False 5 KUNA False True True 6 BINANCEUSDM False False False 7 BITMART True True True 8 UPBIT False True True 9 WAVESEXCHANGE False True True False False 10 OCEANEX False True True False False 11 TIDEBIT False True True False False 12 BITVAVO True True True False False 13 MEXC False True True 14 BITGET True True True False False 15 COINBASEPRIME False False False False False 16 BINANCEUS False False False False False 17 THEROCK False True True 18 EQONEX True True True False False 19 ZB False True True True True 20 STEX True True True False False 21 XENA False True True False False 22 WHITEBIT False True True 23 EXMO False True True 24 BIGONE False True True 25 HITBTC3 False True True 26 EQUOS False False False 27 BITHUMB False True True False False 28 BL3P False True True False False 29 BITMEX False True True False 30 INDODAX False True True False False 31 COINFALCON False True True False False 32 LATOKEN False True True False False 33 OKCOIN True True True 34 BINANCE False True True True True 35 COINMATE True True True False False 36 BITFOREX False True True False False 37 HUOBIJP False True True 38 BTCBOX False True True False False 39 BITTREX False True True False False 40 KUCOIN True True True False 41 BTCMARKETS False True True False False 42 GATEIO True True True True False 43 LBANK False False True False False 44 BITBNS False True True 45 GEMINI False True True False False 46 HUOBI False True True True True 47 BTCALPHA False False True False False 48 COINONE True True True False False 49 HOLLAEX True True True False 50 BW True True True 51 QTRADE False True True False False 52 WOO False True True True 53 TIDEX False True True False False 54 AAX False True True False False 55 ASCENDEX False True True 56 ZIPMEX False False False 57 ZONDA False True True False False 58 PHEMEX True True True False False 59 OKEX5 False False False False False 60 KRAKEN False True True True False 61 OKX True True True True True 62 ZAIF False True True 63 MERCADO False True True False False 64 FTX False True True True True 65 BEQUANT False False False True True 66 KUCOINFUTURES True True True False False 67 LIQUID False True True 68 TIMEX False True True False False 69 BITBANK False False True False False 70 COINBASE True True True False False 71 NOVADAX True True True False False 72 DERIBIT False True True False False 73 ITBIT False True True False False 74 PROBIT True True True False False 75 OKEX False False False False False 76 BITBAY False False False False False 77 BTCTURK False True True False False 78 COINCHECK False True True False False 79 BITSTAMP1 True True True False False 80 WAZIRX False True True 81 BITRUE False True True False False 82 BTCTRADEUA False True True False False 83 BINANCECOINM False False False False False 84 YOBIT False True True False False 85 DELTA True True True 86 BITFINEX2 False True True 87 FTXUS False False True 88 CREX24 False True True False False 89 FLOWBTC False True False False False 90 CURRENCYCOM False True True True 91 BITSO False True True False False 92 BITSTAMP True True True False False 93 LUNO False True True False False 94 CEX True True True 95 INDEPENDENTRESERVE False True True False False 96 BITCOINCOM False False False False False 97 BYBIT False True True False False 98 CRYPTOCOM False True True 99 HUOBIPRO False False False 100 COINEX False True True 101 COINBASEPRO True True True 102 BLOCKCHAINCOM True True True 103 BYTETRADE False True True False False 104 VCC False True True False False 105 BITFINEX False True True 106 BIT2C False True True False False 107 BIBOX False False True False 108 CDAX False True True 109 FMFWIO False False False 110 DIGIFINEX False True True 111 IDEX True True True False False 112 INIT False False False False False 113 PAYMIUM False True True 114 POLONIEX False True True 115 BITPANDA True True True False False 116 NDAX True True True False False 117 LYKKE True True True False False","title":"Ccxt insights 1"},{"location":"dev_guide/stub/","text":"Developer Guide :: stub This will have content explaining everything about how the code works, so that another programmer can understand how it's doing what it's doing and it should make it easier for others to modify & extend what I've built. For example, it will include a bunch of PlantUML Diagrams which clarify each of the classes & the execution of the program.","title":"Developer Guide"},{"location":"dev_guide/stub/#developer-guide","text":":: stub This will have content explaining everything about how the code works, so that another programmer can understand how it's doing what it's doing and it should make it easier for others to modify & extend what I've built. For example, it will include a bunch of PlantUML Diagrams which clarify each of the classes & the execution of the program.","title":"Developer Guide"},{"location":"user_guide/1_installation/","text":"Installation To install the bot firstly make sure that you have python3.10 , pip & git installed. 1. Clone the repository. Since it's a private repo you'll need to have your ssh credentials configured with github and on your machine. Since you're already a member of the repo, once that's done you'll be able to clone it with the following command: git clone git@github.com:N2-Jonathon/n2_pairs_trader.git 2. Create /user/user-config.ini Note I will eventually create a wizard which does this automatically based on user promptscal After you have the repository cloned, the next step is to make the file /user/user-config.ini . This file is in .gitignore because it contains private api keys, which shouldn't be on the repo. In the same directory, you can see a template like the screenshot below: 2.1. Either rename this file to user-config.ini or copy the file and name the second one like that. 2.2. To be able to fill in your telegram api keys, first you need to get them from my.telegram.org Once on my.telegram.org then click on API development tools and create a new app. The title doesn't matter but it will give you two keys: an api_id and an api_hash which you'll need for the notifcations to work. You'll also need to create a channel in telegram which can be either public or private, and the value of notification_channel_id inside user/user-config.ini should be the same as the id for this channel. your username doesn't need the @ symbol prefixed. The phone number should include the +1 at the beginning for a US number. You also don't need any quotation marks for any of the values in the config file. Important The channel ID & channel name aren't the same. The value you need is what comes after t.me/ eg. for the test_channel I made, the id is actually jonathon_test 3. Install python dependencies Navigate to the root of the repository you cloned and then firstly type the command: pip install --upgrade pip Then type the command: pip install -r requirements.txt it will then install the project dependencies and it is now installed. Note that this currently also includes the dependencies for building the documentation, but those will be moved back to requirements_dev.txt and left out of requirements.txt","title":"1. Installation"},{"location":"user_guide/1_installation/#installation","text":"To install the bot firstly make sure that you have python3.10 , pip & git installed.","title":"Installation"},{"location":"user_guide/1_installation/#1-clone-the-repository","text":"Since it's a private repo you'll need to have your ssh credentials configured with github and on your machine. Since you're already a member of the repo, once that's done you'll be able to clone it with the following command: git clone git@github.com:N2-Jonathon/n2_pairs_trader.git","title":"1. Clone the repository."},{"location":"user_guide/1_installation/#2-create-useruser-configini","text":"Note I will eventually create a wizard which does this automatically based on user promptscal After you have the repository cloned, the next step is to make the file /user/user-config.ini . This file is in .gitignore because it contains private api keys, which shouldn't be on the repo. In the same directory, you can see a template like the screenshot below: 2.1. Either rename this file to user-config.ini or copy the file and name the second one like that. 2.2. To be able to fill in your telegram api keys, first you need to get them from my.telegram.org Once on my.telegram.org then click on API development tools and create a new app. The title doesn't matter but it will give you two keys: an api_id and an api_hash which you'll need for the notifcations to work. You'll also need to create a channel in telegram which can be either public or private, and the value of notification_channel_id inside user/user-config.ini should be the same as the id for this channel. your username doesn't need the @ symbol prefixed. The phone number should include the +1 at the beginning for a US number. You also don't need any quotation marks for any of the values in the config file. Important The channel ID & channel name aren't the same. The value you need is what comes after t.me/ eg. for the test_channel I made, the id is actually jonathon_test","title":"2. Create /user/user-config.ini"},{"location":"user_guide/1_installation/#3-install-python-dependencies","text":"Navigate to the root of the repository you cloned and then firstly type the command: pip install --upgrade pip Then type the command: pip install -r requirements.txt it will then install the project dependencies and it is now installed. Note that this currently also includes the dependencies for building the documentation, but those will be moved back to requirements_dev.txt and left out of requirements.txt","title":"3. Install python dependencies"},{"location":"user_guide/2_running-an-instance/","text":"Running An Instance From a terminal, simply navigate to the root of the cloned repository and run the command in your terminal/command prompt: python __main__.py Depending on how your terminal's python path is configured, you may have to write python3 instead of python eg. python3 __main__.py Corrently, it's configured only to work with the values set in user-config.ini I will however implement a user-friendly CLI which makes changing the configuration possible even after starting the bot Todo I'll also make a shell script inside the folder for either running a single instance or multiple instances. When that's done, you'd have to just type in your terminal something like: ./run or ./run-multiple","title":"2. Running an instance"},{"location":"user_guide/2_running-an-instance/#running-an-instance","text":"From a terminal, simply navigate to the root of the cloned repository and run the command in your terminal/command prompt: python __main__.py Depending on how your terminal's python path is configured, you may have to write python3 instead of python eg. python3 __main__.py Corrently, it's configured only to work with the values set in user-config.ini I will however implement a user-friendly CLI which makes changing the configuration possible even after starting the bot Todo I'll also make a shell script inside the folder for either running a single instance or multiple instances. When that's done, you'd have to just type in your terminal something like: ./run or ./run-multiple","title":"Running An Instance"},{"location":"user_guide/3_changing-the-configuration/","text":"Changing the configuration To change the configuration values, currently the only way to do it is to edit the values in user-config.ini For example, the current default base and quote pairs are ETH/USDT & BTC/USDT respectively, meaning that the artificial pair is ETHUSDT/BTCUSDT The coin which has to be borrowed is worked out automatically depending on whether you are opening a long or short position. Note I will move this to the developer guide later. As a user you don't need to care about this but I'm writing it now because it will still have to be explained in the developer guide. Inside the code, the artificial pair or 'synth pair' is read from the configuration file and then stored as a tuple called 'synth_pair_tuple' which basically means a group of values in a specific order. The indexes of this tuple are as follows: [0] Full artificial symbol ie. ETHUSDT/BTCUSDT [1] Base currency of base pair ie. ETH [2] Quote currency of base pair ie. USDT [3] Base currency of quote pair ie. BTC [4] Quote currency of quote pair ie. USDT There's currently no reason why [2] & [4] would be different but it's technically possible to have two pairs with different denominators although that's untested.","title":"3. Changing the configuration"},{"location":"user_guide/3_changing-the-configuration/#changing-the-configuration","text":"To change the configuration values, currently the only way to do it is to edit the values in user-config.ini For example, the current default base and quote pairs are ETH/USDT & BTC/USDT respectively, meaning that the artificial pair is ETHUSDT/BTCUSDT The coin which has to be borrowed is worked out automatically depending on whether you are opening a long or short position. Note I will move this to the developer guide later. As a user you don't need to care about this but I'm writing it now because it will still have to be explained in the developer guide. Inside the code, the artificial pair or 'synth pair' is read from the configuration file and then stored as a tuple called 'synth_pair_tuple' which basically means a group of values in a specific order. The indexes of this tuple are as follows: [0] Full artificial symbol ie. ETHUSDT/BTCUSDT [1] Base currency of base pair ie. ETH [2] Quote currency of base pair ie. USDT [3] Base currency of quote pair ie. BTC [4] Quote currency of quote pair ie. USDT There's currently no reason why [2] & [4] would be different but it's technically possible to have two pairs with different denominators although that's untested.","title":"Changing the configuration"},{"location":"user_guide/4_running-multiple-instances/","text":"Running Multiple Instances :: stub This will have content about how to run multiple instances with different configurations simultaneously, and ideas for how this can be made more convenient.","title":"4. Running multiple instances"},{"location":"user_guide/4_running-multiple-instances/#running-multiple-instances","text":":: stub This will have content about how to run multiple instances with different configurations simultaneously, and ideas for how this can be made more convenient.","title":"Running Multiple Instances"},{"location":"user_guide/5_monitoring-positions/","text":"Monitoring Positions :: stub This will have content about how positions can be monitored via telegram notifications in its current state, and ideas for how this could be made even more convenient.","title":"5. Monitoring Positions"},{"location":"user_guide/5_monitoring-positions/#monitoring-positions","text":":: stub This will have content about how positions can be monitored via telegram notifications in its current state, and ideas for how this could be made even more convenient.","title":"Monitoring Positions"},{"location":"user_guide/temp/","text":"English Hello, This is the first informatik job I've applied to in Switzerland because I am currently working on building a portfolio of things I've built and I don't feel like it's as presentable as it will eventually be. I also have experience with Ununtu, Docker & Containers, cloud services like Digital Ocean, Kamatera & Okteko. That server is using lamp but I also could learn to use nginx. Currently I am working as an independent freelancer with the specific goal of building a portfolio of real-world projects that will enable me to apply for a local swiss job. I've attached my Resume since you requested it, but really most of it is irrelevant to software development and my freelancer profile is like my resume You can see my freelancer reviews I don't have that many yet. (https://www.freelancer.com/u/jonathon3800) (In English) However, soon I am expecting a review for a bigger project I've been working on for the past month which is designed and implemented but still not unit-tested and therefore not complete, so I don't have that review yet. You can view the (incomplete) docs here (In English): http://5.180.183.48/ Note that I plan on creating a portfolio website that will also use mkdocs Actually, that same server has a cloned instance of the trading bot I'm making, and while the repo on github is private, you can view the source code by ssh'ing to the same server: root@5.180.183.48 Password: 'n2cap1234' Then, cd /var/www/repos/n2_pairs_trader and you'll be able to see the source code, and be able to run it by typing python3 __main__.py Please not that this isn't finished, and probably this is premature for me to apply, but I am confident that I'm capable of learning how to do the required job. I do live quite far from Zurich, but I'm happy to take the train every day if I'm able to get an SBB Abo. I have 'technically' been learning to code since 14 years ago, but I was very inconsistent and didn't make that much progress until fairly recently, and I feel like I've reached a new level where I approach things in a way that I imagine a senior developer would, by documenting & explaining things, re-consider my approach, patiently debugging & re-implementing things as needed, and I never give up when I'm stuck or frustrated. I also listen carefully to constructive feedback and try my best to improve every day. I am however still not a senior developer by any stretch. I know that if you hire me I can learn to become a valuable asset to you, even though I've never had an office-job as a developer or system engineer. Thank you for taking the time to read my motivation letter, and at your request I can send my resume but it's worth noting that it doesn't include anything from developer jobs since I've never had any except for my freelance work. Kind regards, Jonathon Deutsch (Google Translate) Hallo, Dies ist der erste Informatik-Job, auf den ich mich in der Schweiz beworben habe, weil ich derzeit daran arbeite, ein Portfolio von Dingen aufzubauen, die ich gebaut habe, und ich glaube nicht, dass es so pr\u00e4sentabel ist, wie es irgendwann sein wird. Ich bin ein gro\u00dfer Linux-Fan und verwende derzeit Manjaro als meinen \u201eDaily Driver\u201c, der ein Fork von Arch Linux ist. Ich habe auch Erfahrung mit Ununtu, Docker & Containern, Cloud-Diensten wie Digital Ocean, Kamatera & Okteko. Dieser Server verwendet eine Lampe, aber ich k\u00f6nnte auch lernen, nginx zu verwenden. Derzeit arbeite ich als unabh\u00e4ngiger Freiberufler mit dem spezifischen Ziel, ein Portfolio von Projekten aus der realen Welt aufzubauen, die es mir erm\u00f6glichen, mich f\u00fcr eine lokale Schweizer Stelle zu bewerben. Sie k\u00f6nnen meine Freelancer-Bewertungen sehen, von denen ich noch nicht so viele habe. (https://www.freelancer.com/u/jonathon3800) (auf Englisch) Bald erwarte ich jedoch eine \u00dcberpr\u00fcfung f\u00fcr ein gr\u00f6\u00dferes Projekt, an dem ich im letzten Monat gearbeitet habe, das entworfen und implementiert, aber noch nicht einheitengetestet und daher nicht abgeschlossen ist, daher habe ich diese \u00dcberpr\u00fcfung noch nicht. Sie k\u00f6nnen die (unvollst\u00e4ndigen) Dokumente hier einsehen (auf Englisch): http://5.180.183.48/ Beachten Sie, dass ich vorhabe, eine Portfolio-Website zu erstellen, die auch mkdocs verwenden wird Tats\u00e4chlich hat derselbe Server eine geklonte Instanz des Trading-Bots, den ich erstelle, und w\u00e4hrend das Repo auf Github privat ist, k\u00f6nnen Sie den Quellcode anzeigen, indem Sie ssh auf denselben Server senden: root@5.180.183.48 Passwort: 'n2cap1234' Dann cd /var/www/repos/n2_pairs_trader und Sie k\u00f6nnen den Quellcode sehen und ihn ausf\u00fchren, indem Sie python3 __main__.py eingeben Bitte beachten Sie, dass dies noch nicht abgeschlossen ist und es wahrscheinlich zu fr\u00fch f\u00fcr eine Bewerbung ist, aber ich bin zuversichtlich, dass ich in der Lage bin, die erforderliche Arbeit zu lernen. Ich wohne zwar ziemlich weit von Z\u00fcrich entfernt, aber ich fahre jeden Tag gerne mit der Bahn, wenn ich ein SBB Abo bekommen kann. Ich lerne \u201etechnisch\u201c seit 14 Jahren Programmieren, aber ich war sehr inkonsequent und habe bis vor kurzem keine gro\u00dfen Fortschritte gemacht, und ich habe das Gef\u00fchl, dass ich eine neue Ebene erreicht habe, auf der ich die Dinge so angehe Ich stelle mir vor, dass ein leitender Entwickler, indem er Dinge dokumentiert und erkl\u00e4rt, meinen Ansatz \u00fcberdenkt, Dinge geduldig debuggt und nach Bedarf neu implementiert, und ich gebe niemals auf, wenn ich feststecke oder frustriert bin. Ich h\u00f6re auch aufmerksam auf konstruktives Feedback und versuche mein Bestes, um mich jeden Tag zu verbessern. Ich bin jedoch noch lange kein Senior-Entwickler. Ich wei\u00df, dass ich, wenn Sie mich einstellen, lernen kann, ein wertvoller Gewinn f\u00fcr Sie zu werden, obwohl ich nie einen B\u00fcrojob als Entwickler oder Systemingenieur hatte. Vielen Dank, dass Sie sich die Zeit genommen haben, mein Motivationsschreiben zu lesen, und auf Ihre Anfrage kann ich meinen Lebenslauf senden, aber es ist erw\u00e4hnenswert, dass er nichts von Entwicklerjobs enth\u00e4lt, da ich au\u00dfer meiner freiberuflichen T\u00e4tigkeit nie welche hatte. Mit freundlichen Gr\u00fc\u00dfen, Jonathon Deutsch (DeepL) Hallo, Dies ist die erste Informatik-Stelle, auf die ich mich in der Schweiz beworben habe, weil ich gerade an einem Portfolio von Dingen arbeite, die ich gebaut habe, und ich habe nicht das Gef\u00fchl, dass es so vorzeigbar ist, wie es letztendlich sein wird. Ich bin ein gro\u00dfer Fan von Linux und benutze derzeit Manjaro als meinen 'Daily Driver', ein Fork von Arch Linux. Ich habe auch Erfahrung mit Ununtu, Docker & Containern, Cloud-Diensten wie Digital Ocean, Kamatera & Okteko. Dieser Server verwendet eine Lampe, aber ich k\u00f6nnte auch lernen, nginx zu verwenden. Zurzeit arbeite ich als unabh\u00e4ngiger Freelancer mit dem Ziel, ein Portfolio von realen Projekten aufzubauen, mit dem ich mich f\u00fcr einen lokalen Schweizer Job bewerben kann. Sie k\u00f6nnen meine Freelancer-Bewertungen sehen, von denen ich noch nicht so viele habe. (https://www.freelancer.com/u/jonathon3800) (Auf Englisch) Allerdings erwarte ich bald eine Bewertung f\u00fcr ein gr\u00f6\u00dferes Projekt, an dem ich seit einem Monat arbeite. Es ist zwar entworfen und implementiert, aber noch nicht getestet und daher noch nicht vollst\u00e4ndig, so dass ich diese Bewertung noch nicht habe. Sie k\u00f6nnen die (unvollst\u00e4ndige) Dokumentation hier einsehen (in Englisch): http://5.180.183.48/ Beachten Sie, dass ich plane, eine Portfolio-Website zu erstellen, die ebenfalls mkdocs verwenden wird. Auf demselben Server befindet sich eine geklonte Instanz des Trading Bots, den ich entwickle, und w\u00e4hrend das Repo auf github privat ist, k\u00f6nnen Sie den Quellcode einsehen, indem Sie sich per ssh auf denselben Server einloggen: root@5.180.183.48 Kennwort: 'n2cap1234' Dann, cd /var/www/repos/n2_pairs_trader und du kannst den Quellcode sehen und ihn durch Eingabe von python3 __main__.py ausf\u00fchren Bitte beachten Sie, dass das Projekt noch nicht abgeschlossen ist und es wahrscheinlich zu fr\u00fch ist, um sich zu bewerben, aber ich bin zuversichtlich, dass ich in der Lage bin zu lernen, wie man die geforderte Arbeit erledigt. Ich wohne zwar recht weit von Z\u00fcrich entfernt, bin aber gerne bereit, jeden Tag mit dem Zug zu fahren, wenn ich ein SBB Abo bekomme. Technisch gesehen lerne ich seit 14 Jahren zu programmieren, aber ich war sehr inkonsequent und habe bis vor kurzem keine gro\u00dfen Fortschritte gemacht. Ich habe das Gef\u00fchl, dass ich ein neues Niveau erreicht habe, bei dem ich die Dinge so angehe, wie ich mir vorstelle, dass ein erfahrener Entwickler es tun w\u00fcrde, indem ich Dinge dokumentiere und erkl\u00e4re, meine Herangehensweise \u00fcberdenke, geduldig Fehler behebe und Dinge bei Bedarf neu implementiere, und ich gebe nie auf, wenn ich nicht weiterkomme oder frustriert bin. Au\u00dferdem h\u00f6re ich mir konstruktives Feedback genau an und versuche mein Bestes, um mich jeden Tag zu verbessern. Ich bin jedoch noch lange kein Senior-Entwickler. Ich wei\u00df, dass ich, wenn Sie mich einstellen, lernen kann, eine wertvolle Bereicherung f\u00fcr Sie zu werden, auch wenn ich noch nie einen B\u00fcrojob als Entwickler oder Systemingenieur hatte. Ich danke Ihnen, dass Sie sich die Zeit genommen haben, mein Motivationsschreiben zu lesen, und auf Ihre Bitte hin kann ich Ihnen meinen Lebenslauf schicken, aber es ist erw\u00e4hnenswert, dass er fv keine Jobs als Entwickler enth\u00e4lt, da ich au\u00dfer meiner freiberuflichen Arbeit noch nie welche hatte. Mit freundlichen Gr\u00fc\u00dfen, Jonathon","title":"Temp"},{"location":"user_guide/temp/#english","text":"Hello, This is the first informatik job I've applied to in Switzerland because I am currently working on building a portfolio of things I've built and I don't feel like it's as presentable as it will eventually be. I also have experience with Ununtu, Docker & Containers, cloud services like Digital Ocean, Kamatera & Okteko. That server is using lamp but I also could learn to use nginx. Currently I am working as an independent freelancer with the specific goal of building a portfolio of real-world projects that will enable me to apply for a local swiss job. I've attached my Resume since you requested it, but really most of it is irrelevant to software development and my freelancer profile is like my resume You can see my freelancer reviews I don't have that many yet. (https://www.freelancer.com/u/jonathon3800) (In English) However, soon I am expecting a review for a bigger project I've been working on for the past month which is designed and implemented but still not unit-tested and therefore not complete, so I don't have that review yet. You can view the (incomplete) docs here (In English): http://5.180.183.48/ Note that I plan on creating a portfolio website that will also use mkdocs Actually, that same server has a cloned instance of the trading bot I'm making, and while the repo on github is private, you can view the source code by ssh'ing to the same server: root@5.180.183.48 Password: 'n2cap1234' Then, cd /var/www/repos/n2_pairs_trader and you'll be able to see the source code, and be able to run it by typing python3 __main__.py Please not that this isn't finished, and probably this is premature for me to apply, but I am confident that I'm capable of learning how to do the required job. I do live quite far from Zurich, but I'm happy to take the train every day if I'm able to get an SBB Abo. I have 'technically' been learning to code since 14 years ago, but I was very inconsistent and didn't make that much progress until fairly recently, and I feel like I've reached a new level where I approach things in a way that I imagine a senior developer would, by documenting & explaining things, re-consider my approach, patiently debugging & re-implementing things as needed, and I never give up when I'm stuck or frustrated. I also listen carefully to constructive feedback and try my best to improve every day. I am however still not a senior developer by any stretch. I know that if you hire me I can learn to become a valuable asset to you, even though I've never had an office-job as a developer or system engineer. Thank you for taking the time to read my motivation letter, and at your request I can send my resume but it's worth noting that it doesn't include anything from developer jobs since I've never had any except for my freelance work. Kind regards, Jonathon","title":"English"},{"location":"user_guide/temp/#deutsch-google-translate","text":"Hallo, Dies ist der erste Informatik-Job, auf den ich mich in der Schweiz beworben habe, weil ich derzeit daran arbeite, ein Portfolio von Dingen aufzubauen, die ich gebaut habe, und ich glaube nicht, dass es so pr\u00e4sentabel ist, wie es irgendwann sein wird. Ich bin ein gro\u00dfer Linux-Fan und verwende derzeit Manjaro als meinen \u201eDaily Driver\u201c, der ein Fork von Arch Linux ist. Ich habe auch Erfahrung mit Ununtu, Docker & Containern, Cloud-Diensten wie Digital Ocean, Kamatera & Okteko. Dieser Server verwendet eine Lampe, aber ich k\u00f6nnte auch lernen, nginx zu verwenden. Derzeit arbeite ich als unabh\u00e4ngiger Freiberufler mit dem spezifischen Ziel, ein Portfolio von Projekten aus der realen Welt aufzubauen, die es mir erm\u00f6glichen, mich f\u00fcr eine lokale Schweizer Stelle zu bewerben. Sie k\u00f6nnen meine Freelancer-Bewertungen sehen, von denen ich noch nicht so viele habe. (https://www.freelancer.com/u/jonathon3800) (auf Englisch) Bald erwarte ich jedoch eine \u00dcberpr\u00fcfung f\u00fcr ein gr\u00f6\u00dferes Projekt, an dem ich im letzten Monat gearbeitet habe, das entworfen und implementiert, aber noch nicht einheitengetestet und daher nicht abgeschlossen ist, daher habe ich diese \u00dcberpr\u00fcfung noch nicht. Sie k\u00f6nnen die (unvollst\u00e4ndigen) Dokumente hier einsehen (auf Englisch): http://5.180.183.48/ Beachten Sie, dass ich vorhabe, eine Portfolio-Website zu erstellen, die auch mkdocs verwenden wird Tats\u00e4chlich hat derselbe Server eine geklonte Instanz des Trading-Bots, den ich erstelle, und w\u00e4hrend das Repo auf Github privat ist, k\u00f6nnen Sie den Quellcode anzeigen, indem Sie ssh auf denselben Server senden: root@5.180.183.48 Passwort: 'n2cap1234' Dann cd /var/www/repos/n2_pairs_trader und Sie k\u00f6nnen den Quellcode sehen und ihn ausf\u00fchren, indem Sie python3 __main__.py eingeben Bitte beachten Sie, dass dies noch nicht abgeschlossen ist und es wahrscheinlich zu fr\u00fch f\u00fcr eine Bewerbung ist, aber ich bin zuversichtlich, dass ich in der Lage bin, die erforderliche Arbeit zu lernen. Ich wohne zwar ziemlich weit von Z\u00fcrich entfernt, aber ich fahre jeden Tag gerne mit der Bahn, wenn ich ein SBB Abo bekommen kann. Ich lerne \u201etechnisch\u201c seit 14 Jahren Programmieren, aber ich war sehr inkonsequent und habe bis vor kurzem keine gro\u00dfen Fortschritte gemacht, und ich habe das Gef\u00fchl, dass ich eine neue Ebene erreicht habe, auf der ich die Dinge so angehe Ich stelle mir vor, dass ein leitender Entwickler, indem er Dinge dokumentiert und erkl\u00e4rt, meinen Ansatz \u00fcberdenkt, Dinge geduldig debuggt und nach Bedarf neu implementiert, und ich gebe niemals auf, wenn ich feststecke oder frustriert bin. Ich h\u00f6re auch aufmerksam auf konstruktives Feedback und versuche mein Bestes, um mich jeden Tag zu verbessern. Ich bin jedoch noch lange kein Senior-Entwickler. Ich wei\u00df, dass ich, wenn Sie mich einstellen, lernen kann, ein wertvoller Gewinn f\u00fcr Sie zu werden, obwohl ich nie einen B\u00fcrojob als Entwickler oder Systemingenieur hatte. Vielen Dank, dass Sie sich die Zeit genommen haben, mein Motivationsschreiben zu lesen, und auf Ihre Anfrage kann ich meinen Lebenslauf senden, aber es ist erw\u00e4hnenswert, dass er nichts von Entwicklerjobs enth\u00e4lt, da ich au\u00dfer meiner freiberuflichen T\u00e4tigkeit nie welche hatte. Mit freundlichen Gr\u00fc\u00dfen, Jonathon","title":"Deutsch (Google Translate)"},{"location":"user_guide/temp/#deutsch-deepl","text":"Hallo, Dies ist die erste Informatik-Stelle, auf die ich mich in der Schweiz beworben habe, weil ich gerade an einem Portfolio von Dingen arbeite, die ich gebaut habe, und ich habe nicht das Gef\u00fchl, dass es so vorzeigbar ist, wie es letztendlich sein wird. Ich bin ein gro\u00dfer Fan von Linux und benutze derzeit Manjaro als meinen 'Daily Driver', ein Fork von Arch Linux. Ich habe auch Erfahrung mit Ununtu, Docker & Containern, Cloud-Diensten wie Digital Ocean, Kamatera & Okteko. Dieser Server verwendet eine Lampe, aber ich k\u00f6nnte auch lernen, nginx zu verwenden. Zurzeit arbeite ich als unabh\u00e4ngiger Freelancer mit dem Ziel, ein Portfolio von realen Projekten aufzubauen, mit dem ich mich f\u00fcr einen lokalen Schweizer Job bewerben kann. Sie k\u00f6nnen meine Freelancer-Bewertungen sehen, von denen ich noch nicht so viele habe. (https://www.freelancer.com/u/jonathon3800) (Auf Englisch) Allerdings erwarte ich bald eine Bewertung f\u00fcr ein gr\u00f6\u00dferes Projekt, an dem ich seit einem Monat arbeite. Es ist zwar entworfen und implementiert, aber noch nicht getestet und daher noch nicht vollst\u00e4ndig, so dass ich diese Bewertung noch nicht habe. Sie k\u00f6nnen die (unvollst\u00e4ndige) Dokumentation hier einsehen (in Englisch): http://5.180.183.48/ Beachten Sie, dass ich plane, eine Portfolio-Website zu erstellen, die ebenfalls mkdocs verwenden wird. Auf demselben Server befindet sich eine geklonte Instanz des Trading Bots, den ich entwickle, und w\u00e4hrend das Repo auf github privat ist, k\u00f6nnen Sie den Quellcode einsehen, indem Sie sich per ssh auf denselben Server einloggen: root@5.180.183.48 Kennwort: 'n2cap1234' Dann, cd /var/www/repos/n2_pairs_trader und du kannst den Quellcode sehen und ihn durch Eingabe von python3 __main__.py ausf\u00fchren Bitte beachten Sie, dass das Projekt noch nicht abgeschlossen ist und es wahrscheinlich zu fr\u00fch ist, um sich zu bewerben, aber ich bin zuversichtlich, dass ich in der Lage bin zu lernen, wie man die geforderte Arbeit erledigt. Ich wohne zwar recht weit von Z\u00fcrich entfernt, bin aber gerne bereit, jeden Tag mit dem Zug zu fahren, wenn ich ein SBB Abo bekomme. Technisch gesehen lerne ich seit 14 Jahren zu programmieren, aber ich war sehr inkonsequent und habe bis vor kurzem keine gro\u00dfen Fortschritte gemacht. Ich habe das Gef\u00fchl, dass ich ein neues Niveau erreicht habe, bei dem ich die Dinge so angehe, wie ich mir vorstelle, dass ein erfahrener Entwickler es tun w\u00fcrde, indem ich Dinge dokumentiere und erkl\u00e4re, meine Herangehensweise \u00fcberdenke, geduldig Fehler behebe und Dinge bei Bedarf neu implementiere, und ich gebe nie auf, wenn ich nicht weiterkomme oder frustriert bin. Au\u00dferdem h\u00f6re ich mir konstruktives Feedback genau an und versuche mein Bestes, um mich jeden Tag zu verbessern. Ich bin jedoch noch lange kein Senior-Entwickler. Ich wei\u00df, dass ich, wenn Sie mich einstellen, lernen kann, eine wertvolle Bereicherung f\u00fcr Sie zu werden, auch wenn ich noch nie einen B\u00fcrojob als Entwickler oder Systemingenieur hatte. Ich danke Ihnen, dass Sie sich die Zeit genommen haben, mein Motivationsschreiben zu lesen, und auf Ihre Bitte hin kann ich Ihnen meinen Lebenslauf schicken, aber es ist erw\u00e4hnenswert, dass er fv keine Jobs als Entwickler enth\u00e4lt, da ich au\u00dfer meiner freiberuflichen Arbeit noch nie welche hatte. Mit freundlichen Gr\u00fc\u00dfen, Jonathon","title":"Deutsch (DeepL)"},{"location":"user_guide/old/1_start_the_bot/","text":"1. Start the bot: From a terminal, run python __main__.py Inside __main__.py , the run_bot() function is called which takes the optional param strategy= . When it's not specified, it currently defaults to strategy=N2SuperTrend() which initializes the strategy. if __name__ == '__main__' : run_bot () # Can pass a Strategy to override default eg. run_bot(strategy=YourStrategy) you can edit this part of __main__.py to override the default strategy. you also need to import the Strategy at the top of __main__ : from strategies.another_strategy import AnotherStrategy ... if __name__ == '__main__' : run_bot ( strategy = AnotherStrategy ()) TODO : I want to make it so that it you can pass the strategy as an argument from terminal, which could be useful for implementing backtesting","title":"1. Start the bot:"},{"location":"user_guide/old/1_start_the_bot/#1-start-the-bot","text":"From a terminal, run python __main__.py Inside __main__.py , the run_bot() function is called which takes the optional param strategy= . When it's not specified, it currently defaults to strategy=N2SuperTrend() which initializes the strategy. if __name__ == '__main__' : run_bot () # Can pass a Strategy to override default eg. run_bot(strategy=YourStrategy) you can edit this part of __main__.py to override the default strategy. you also need to import the Strategy at the top of __main__ : from strategies.another_strategy import AnotherStrategy ... if __name__ == '__main__' : run_bot ( strategy = AnotherStrategy ()) TODO : I want to make it so that it you can pass the strategy as an argument from terminal, which could be useful for implementing backtesting","title":"1. Start the bot:"},{"location":"user_guide/old/2_initialize_strategy/","text":"2. Initialize strategy When a strategy class eg. N2SuperTrend is initialized without params then it loads the values set in user/user-config.ini def run_bot ( strategy = N2SuperTrend ()): ... At this point, you can access the following Fields inherited by StrategyBase : strategy . exchange : str , strategy . strategy_name : str , strategy . prompt_for_pairs : bool , strategy . base_pair : str , strategy . quote_pair : str , strategy . synth_pair : str , # Not sure if this is set properly by __init__ yet strategy . stake_currency : str , strategy . paper_trade : bool , strategy . position_manager : PositionManager , strategy . previous_tick : datetime , strategy . ohlcv_data : dict , strategy . signal : str , strategy . multi_timeframe_mode : bool strategy . multi_timeframe_signal_rules : dict 2.2 How a strategy is initialized behind the scenes: What happens when the strategy object is instantiated eg. strategy = N2SuperTrend() is that the __init__ method inside the N2SuperTrend class is called: class N2SuperTrend ( StrategyBase ): def __init__ ( self , params = {}, config_filepath = USER_CONFIG_PATH ): \"\"\" The first line `super().__init__(params, config_filepath)` means it runs the __init__ method in StrategyBase and inherits its attributes from there, then the name is set. :param params: :type params: :param config_filepath: :type config_filepath: \"\"\" super () . __init__ ( params , config_filepath ) self . name = 'n2_supertrend' This is all you'd need to put in the __init__ of any new strategy, and then put the strategy's logic for how it generates a signal inside of the method YourStrategy.get_signal() Like it says in the comment, the super() function on the first line runs the __init__ of the StrategyBase class so it inherits all the attributes and methods of StrategyBase and then it assigns a name for the strategy. Here's what's happening in StrategyBase.__init__() where the program executes next before coming back to N2SuperTrend : from core.config import Config class StrategyBase ( Config ): \"\"\" A strategy is an object whose main purpose is to contain regularly updated market data by pulling OHLCV data from both the base pair and the quote pair, then combining them to make the synth pair, keeping track of PnL for both underlying trades. The main logic which is specific to your strategy should be implemented in the `get_signal()` method which should then be called at a regular defined interval. The signal can be set either to be for a single timeframe or multiple timeframes by setting the value of `multi_timeframe_signal_mode: Bool` for that strategy. \"\"\" ... def __int__ ( self , params = {}, config_filepath = USER_CONFIG_PATH ): \"\"\" The first line: `super().__init__(params, config_filepath)` means it runs the __init__ method in Config and inherits its attributes from there, then after that, the other attributes are set. :param params: :type params: :param config_filepath: :type config_filepath: :return: :rtype: \"\"\" super () . __init__ ( self , params , config_filepath ) self . name = None self . current_signal = None self . position_manager = PositionManager () The StrategyBase class inherits the Config class and calls the super() function on the first line too, which calls the __init__() of Config . Config doesn't inherit anything and it's a base class for other classes to inherit. It provides an extra layer between the strategy and lower level configuration options eg. [TODO] OHCLV data source should be configurable so that later when making a backtesting environment that will be given historic market data and a much faster tick interval, it will be possible to have multiple instances of running strategies configured differently. It shouldn't need to be edited unless developing/debugging): This is what happens in Config.__init__() where the program executes next before coming back to StrategyBase.__init__() . class Config : __dict__ = { \"exchange\" : str , \"strategy_name\" : str , \"prompt_for_pairs\" : bool , \"base_pair\" : str , \"quote_pair\" : str , \"stake_currency\" : str , \"paper_trade\" : bool , \"debug_mode\" : bool } cfg_parser = ConfigParser () def __init__ ( self , params = {}, filepath = USER_CONFIG_PATH ): \"\"\" **[TODO]**: the API Keys should be read from the config.ini file or given as params then saved in self.exchange_api_keys: dict instead of how I'm currently handling how API keys are accessed which isn't the best way. Then, self.exchange can be initialized taking self.exchange_api_keys as a param. \"\"\" self . params = params if params is None or len ( params ) == 0 : if filepath is not None : self . cfg_parser . read ([ filepath ]) elif filepath is None : raise ValueError try : self . exchange_id = self . cfg_parser [ 'Global Settings' ][ 'exchange' ] self . strategy_name = self . cfg_parser [ 'Global Settings' ][ 'strategy' ] self . strategy_import_path = f \"strategies. { self . strategy_name } \" self . prompt_for_pairs = bool ( self . cfg_parser [ 'Global Settings' ][ 'prompt_for_pairs' ]) self . base_pair = self . cfg_parser [ 'Global Settings' ][ 'base_pair_default' ] self . quote_pair = self . cfg_parser [ 'Global Settings' ][ 'quote_pair_default' ] self . stake_currency = self . cfg_parser [ 'Global Settings' ][ 'stake_currency' ] self . paper_trade = bool ( self . cfg_parser [ 'Global Settings' ][ 'paper_trade' ]) # self.synth_pair = self.get_synth_pair_symbol(self.base_pair, self.quote_pair) # self.strategy = importlib.import_module(f\"strategies.{self.strategy_name}\") # self.exchange: ccxt.Exchange = self.enabled_exchanges[self.cfg_file_key] except : raise ValueError ( \"Failed to read from config (Make sure all values are assigned)\" ) elif self . params is not None : for param in self . params : if param not in self . __dict__ : raise ValueError ( f \"Invalid Parameter: ' { param } '\" ) try : self . exchange_id : str = self . params [ 'exchange' ] self . strategy_name = self . params [ 'strategy' ] self . strategy_import_path = f \"strategies. { self . strategy_name [ 'strategy' ] } \" self . prompt_for_pairs : bool = params [ 'prompt_for_pairs' ], self . base_pair : str = params [ 'base_pair' ], self . quote_pair : str = params [ 'quote_pair' ], self . stake_currency : str = params [ 'stake_currency' ] self . paper_trade : bool = params [ 'paper_trade' ] # self.strategy = importlib.import_module(f\"strategies.{self.strategy_name}\") # self.exchange: ccxt.Exchange = self.enabled_exchanges[self.cfg_file_key] except : raise ValueError ( \"Params incomplete\" ) else : raise Exception ( \"Cannot Initialize Config() without either params or config_filepath\" ) self . synth_pair = utils . get_synth_pair_tuple ( self . base_pair , self . quote_pair ) self . enabled_exchanges = self . get_enabled_exchanges () self . exchange : ccxt . Exchange = self . enabled_exchanges [ self . exchange_id . lower ()] What it's doing is checking to see if params were supplied to override the default config. If params are passed to Config or any of its subclasses ie. StrategyBase or N2SuperTrend are instantiated, then it will load those params as a configuration. If params are not supplied, it will use a config.ini file specified by filepath , which defaults to the global constant USER_CONFIG_PATH (This is set in core.constants to user/user-config.ini )","title":"2. Initialize strategy"},{"location":"user_guide/old/2_initialize_strategy/#2-initialize-strategy","text":"When a strategy class eg. N2SuperTrend is initialized without params then it loads the values set in user/user-config.ini def run_bot ( strategy = N2SuperTrend ()): ... At this point, you can access the following Fields inherited by StrategyBase : strategy . exchange : str , strategy . strategy_name : str , strategy . prompt_for_pairs : bool , strategy . base_pair : str , strategy . quote_pair : str , strategy . synth_pair : str , # Not sure if this is set properly by __init__ yet strategy . stake_currency : str , strategy . paper_trade : bool , strategy . position_manager : PositionManager , strategy . previous_tick : datetime , strategy . ohlcv_data : dict , strategy . signal : str , strategy . multi_timeframe_mode : bool strategy . multi_timeframe_signal_rules : dict","title":"2. Initialize strategy"},{"location":"user_guide/old/2_initialize_strategy/#22-how-a-strategy-is-initialized-behind-the-scenes","text":"What happens when the strategy object is instantiated eg. strategy = N2SuperTrend() is that the __init__ method inside the N2SuperTrend class is called: class N2SuperTrend ( StrategyBase ): def __init__ ( self , params = {}, config_filepath = USER_CONFIG_PATH ): \"\"\" The first line `super().__init__(params, config_filepath)` means it runs the __init__ method in StrategyBase and inherits its attributes from there, then the name is set. :param params: :type params: :param config_filepath: :type config_filepath: \"\"\" super () . __init__ ( params , config_filepath ) self . name = 'n2_supertrend' This is all you'd need to put in the __init__ of any new strategy, and then put the strategy's logic for how it generates a signal inside of the method YourStrategy.get_signal() Like it says in the comment, the super() function on the first line runs the __init__ of the StrategyBase class so it inherits all the attributes and methods of StrategyBase and then it assigns a name for the strategy. Here's what's happening in StrategyBase.__init__() where the program executes next before coming back to N2SuperTrend : from core.config import Config class StrategyBase ( Config ): \"\"\" A strategy is an object whose main purpose is to contain regularly updated market data by pulling OHLCV data from both the base pair and the quote pair, then combining them to make the synth pair, keeping track of PnL for both underlying trades. The main logic which is specific to your strategy should be implemented in the `get_signal()` method which should then be called at a regular defined interval. The signal can be set either to be for a single timeframe or multiple timeframes by setting the value of `multi_timeframe_signal_mode: Bool` for that strategy. \"\"\" ... def __int__ ( self , params = {}, config_filepath = USER_CONFIG_PATH ): \"\"\" The first line: `super().__init__(params, config_filepath)` means it runs the __init__ method in Config and inherits its attributes from there, then after that, the other attributes are set. :param params: :type params: :param config_filepath: :type config_filepath: :return: :rtype: \"\"\" super () . __init__ ( self , params , config_filepath ) self . name = None self . current_signal = None self . position_manager = PositionManager () The StrategyBase class inherits the Config class and calls the super() function on the first line too, which calls the __init__() of Config . Config doesn't inherit anything and it's a base class for other classes to inherit. It provides an extra layer between the strategy and lower level configuration options eg. [TODO] OHCLV data source should be configurable so that later when making a backtesting environment that will be given historic market data and a much faster tick interval, it will be possible to have multiple instances of running strategies configured differently. It shouldn't need to be edited unless developing/debugging): This is what happens in Config.__init__() where the program executes next before coming back to StrategyBase.__init__() . class Config : __dict__ = { \"exchange\" : str , \"strategy_name\" : str , \"prompt_for_pairs\" : bool , \"base_pair\" : str , \"quote_pair\" : str , \"stake_currency\" : str , \"paper_trade\" : bool , \"debug_mode\" : bool } cfg_parser = ConfigParser () def __init__ ( self , params = {}, filepath = USER_CONFIG_PATH ): \"\"\" **[TODO]**: the API Keys should be read from the config.ini file or given as params then saved in self.exchange_api_keys: dict instead of how I'm currently handling how API keys are accessed which isn't the best way. Then, self.exchange can be initialized taking self.exchange_api_keys as a param. \"\"\" self . params = params if params is None or len ( params ) == 0 : if filepath is not None : self . cfg_parser . read ([ filepath ]) elif filepath is None : raise ValueError try : self . exchange_id = self . cfg_parser [ 'Global Settings' ][ 'exchange' ] self . strategy_name = self . cfg_parser [ 'Global Settings' ][ 'strategy' ] self . strategy_import_path = f \"strategies. { self . strategy_name } \" self . prompt_for_pairs = bool ( self . cfg_parser [ 'Global Settings' ][ 'prompt_for_pairs' ]) self . base_pair = self . cfg_parser [ 'Global Settings' ][ 'base_pair_default' ] self . quote_pair = self . cfg_parser [ 'Global Settings' ][ 'quote_pair_default' ] self . stake_currency = self . cfg_parser [ 'Global Settings' ][ 'stake_currency' ] self . paper_trade = bool ( self . cfg_parser [ 'Global Settings' ][ 'paper_trade' ]) # self.synth_pair = self.get_synth_pair_symbol(self.base_pair, self.quote_pair) # self.strategy = importlib.import_module(f\"strategies.{self.strategy_name}\") # self.exchange: ccxt.Exchange = self.enabled_exchanges[self.cfg_file_key] except : raise ValueError ( \"Failed to read from config (Make sure all values are assigned)\" ) elif self . params is not None : for param in self . params : if param not in self . __dict__ : raise ValueError ( f \"Invalid Parameter: ' { param } '\" ) try : self . exchange_id : str = self . params [ 'exchange' ] self . strategy_name = self . params [ 'strategy' ] self . strategy_import_path = f \"strategies. { self . strategy_name [ 'strategy' ] } \" self . prompt_for_pairs : bool = params [ 'prompt_for_pairs' ], self . base_pair : str = params [ 'base_pair' ], self . quote_pair : str = params [ 'quote_pair' ], self . stake_currency : str = params [ 'stake_currency' ] self . paper_trade : bool = params [ 'paper_trade' ] # self.strategy = importlib.import_module(f\"strategies.{self.strategy_name}\") # self.exchange: ccxt.Exchange = self.enabled_exchanges[self.cfg_file_key] except : raise ValueError ( \"Params incomplete\" ) else : raise Exception ( \"Cannot Initialize Config() without either params or config_filepath\" ) self . synth_pair = utils . get_synth_pair_tuple ( self . base_pair , self . quote_pair ) self . enabled_exchanges = self . get_enabled_exchanges () self . exchange : ccxt . Exchange = self . enabled_exchanges [ self . exchange_id . lower ()] What it's doing is checking to see if params were supplied to override the default config. If params are passed to Config or any of its subclasses ie. StrategyBase or N2SuperTrend are instantiated, then it will load those params as a configuration. If params are not supplied, it will use a config.ini file specified by filepath , which defaults to the global constant USER_CONFIG_PATH (This is set in core.constants to user/user-config.ini )","title":"2.2 How a strategy is initialized behind the scenes:"},{"location":"user_guide/old/3_signals/","text":"3. Market Data & Signals: The strategy will have its own ccxt.Exchange type initialized with api keys read from the user config that gets stored in self.exchange and PositionManager object as a Fields and which can be accessed from inside or outside of the strategy class (better inside): Going back to the run_bot() function in main .py: def run_bot ( strategy = N2SuperTrend ()): running = True pm : PositionManager = strategy . position_manager while running : if strategy . debug_mode : \"\"\"If in debug mode, prompt for signal override\"\"\" override_signal = input ( \"[DEBUG]Enter a signal to emulate: ([LONG]|SHORT|CLOSE)\" ) if override_signal == \"\" : signal = 'LONG' # Default if you just press enter at the prompt elif override_signal . upper () == 'SHORT' or override_signal == 'LONG' : signal = override_signal else : \"\"\"If not in debug mode, call the get_signal method of the strategy\"\"\" signal = strategy . listen_for_signals () ... if __name__ == '__main__' : run_bot () # Can pass a Strategy to override default eg. main(strategy=YourStrategy) First, the strategy's PositionManager is assigned to the variable pm (can be called anything) Then, it enters a while loop: while running: This while loop is essentially one tick, and it would be better to move this out of __main__.py and into a a new method of StrategyBase or Config : called run() or start() I haven't yet accounted for rate limits, but it's possible to fetch rate limits for an exchange with ccxt. Getting a signal from the strategy When the strategy.get_signal method is called, it will run whatever logic you have defined in that method for your strategy. If you don't create a method in your strategy called get_signal , it will default to the one in StrategyBase and raise a NotImplemented error: Otherwise, when you do define a get_signal method, it will override the one in StrategyBase and you can implement whatever logic and conditions to generate the strategy's net signal in that method. The signal can either based on one timeframe or you can enable and define Multi-timeframe signal rules as a dict with keys for each timeframe that have bool values. Whichever timeframes are set to true, must reach a consensus of their signals for them to generate an aggregated signal. [TODO] : make it so that in multi-timeframe mode, instead of fetching signals for all timeframes at every tick, they will each have different intervals to stay within rate limits. I also need to change how get_signal is currently fetching historic bars every time it's called when it should only need to do that once, and then update the price with live tick data from by using ccxt.Exchange.fetch_ticker() def run_bot ( strategy = N2SuperTrend ()): running = True pm : PositionManager = strategy . position_manager while running : ... signal = strategy . listen_for_signals () if signal is not None and signal != 'CLOSE' : \"\"\"If there is a new signal to LONG or SHORT:\"\"\" if pm . get_current_position () is None : \"\"\" If there's no current position open, then open one in the signal of the signal and set it as pm's current_position \"\"\" position = Position ( strategy . base_pair , strategy . quote_pair , direction = signal , order_type = 'limit' ) . open () # TODO: Here is where the `core.notifier` class would be # used to report the opening of the position and send # send a notification via telegram and/or email. pm . set_current_position ( position ) elif signal == 'CLOSE' : \"\"\" If the signal is 'CLOSE', then close the pm.current_position \"\"\" pm . current_position . close () # TODO: Here `core.notifier` would be used again to report # the closing of the trade and send via email/telegram tick_interval = 60 # This should be adjusted to take API rate limits into account \"\"\"For now the tick_interval is set here, but it should be set by params config file by Config.__init__()\"\"\" time . sleep ( tick_interval ) # await asyncio.sleep(tick_interval)","title":"3. Market Data & Signals:"},{"location":"user_guide/old/3_signals/#3-market-data-signals","text":"The strategy will have its own ccxt.Exchange type initialized with api keys read from the user config that gets stored in self.exchange and PositionManager object as a Fields and which can be accessed from inside or outside of the strategy class (better inside):","title":"3. Market Data &amp; Signals:"},{"location":"user_guide/old/3_signals/#going-back-to-the-run_bot-function-in-mainpy","text":"def run_bot ( strategy = N2SuperTrend ()): running = True pm : PositionManager = strategy . position_manager while running : if strategy . debug_mode : \"\"\"If in debug mode, prompt for signal override\"\"\" override_signal = input ( \"[DEBUG]Enter a signal to emulate: ([LONG]|SHORT|CLOSE)\" ) if override_signal == \"\" : signal = 'LONG' # Default if you just press enter at the prompt elif override_signal . upper () == 'SHORT' or override_signal == 'LONG' : signal = override_signal else : \"\"\"If not in debug mode, call the get_signal method of the strategy\"\"\" signal = strategy . listen_for_signals () ... if __name__ == '__main__' : run_bot () # Can pass a Strategy to override default eg. main(strategy=YourStrategy) First, the strategy's PositionManager is assigned to the variable pm (can be called anything) Then, it enters a while loop: while running: This while loop is essentially one tick, and it would be better to move this out of __main__.py and into a a new method of StrategyBase or Config : called run() or start() I haven't yet accounted for rate limits, but it's possible to fetch rate limits for an exchange with ccxt.","title":"Going back to the run_bot() function in main.py:"},{"location":"user_guide/old/3_signals/#getting-a-signal-from-the-strategy","text":"When the strategy.get_signal method is called, it will run whatever logic you have defined in that method for your strategy. If you don't create a method in your strategy called get_signal , it will default to the one in StrategyBase and raise a NotImplemented error: Otherwise, when you do define a get_signal method, it will override the one in StrategyBase and you can implement whatever logic and conditions to generate the strategy's net signal in that method. The signal can either based on one timeframe or you can enable and define Multi-timeframe signal rules as a dict with keys for each timeframe that have bool values. Whichever timeframes are set to true, must reach a consensus of their signals for them to generate an aggregated signal. [TODO] : make it so that in multi-timeframe mode, instead of fetching signals for all timeframes at every tick, they will each have different intervals to stay within rate limits. I also need to change how get_signal is currently fetching historic bars every time it's called when it should only need to do that once, and then update the price with live tick data from by using ccxt.Exchange.fetch_ticker() def run_bot ( strategy = N2SuperTrend ()): running = True pm : PositionManager = strategy . position_manager while running : ... signal = strategy . listen_for_signals () if signal is not None and signal != 'CLOSE' : \"\"\"If there is a new signal to LONG or SHORT:\"\"\" if pm . get_current_position () is None : \"\"\" If there's no current position open, then open one in the signal of the signal and set it as pm's current_position \"\"\" position = Position ( strategy . base_pair , strategy . quote_pair , direction = signal , order_type = 'limit' ) . open () # TODO: Here is where the `core.notifier` class would be # used to report the opening of the position and send # send a notification via telegram and/or email. pm . set_current_position ( position ) elif signal == 'CLOSE' : \"\"\" If the signal is 'CLOSE', then close the pm.current_position \"\"\" pm . current_position . close () # TODO: Here `core.notifier` would be used again to report # the closing of the trade and send via email/telegram tick_interval = 60 # This should be adjusted to take API rate limits into account \"\"\"For now the tick_interval is set here, but it should be set by params config file by Config.__init__()\"\"\" time . sleep ( tick_interval ) # await asyncio.sleep(tick_interval)","title":"Getting a signal from the strategy"},{"location":"user_guide/old/4_opening_a_position/","text":"4. Opening a Position: A position can be opened either by using the open() method of the Position class: position = Position ( base_pair , quote_pair , direction = signal , order_type = 'limit' ) . open () Or, an instance/object of that class (which inherits self.base_pair & self.quote_pair): from strategies.your_strategy import YourStrategy strategy = YourStrategy pm = YourStrategy . position_manager () position = pm . Position ( direction = signal , order_type = 'limit' ) . open ()","title":"4. Opening a Position:"},{"location":"user_guide/old/4_opening_a_position/#4-opening-a-position","text":"A position can be opened either by using the open() method of the Position class: position = Position ( base_pair , quote_pair , direction = signal , order_type = 'limit' ) . open () Or, an instance/object of that class (which inherits self.base_pair & self.quote_pair): from strategies.your_strategy import YourStrategy strategy = YourStrategy pm = YourStrategy . position_manager () position = pm . Position ( direction = signal , order_type = 'limit' ) . open ()","title":"4. Opening a Position:"},{"location":"user_guide/old/5_closing_a_position/","text":"5. Closing a position: :: stub","title":"5. Closing a position:"},{"location":"user_guide/old/5_closing_a_position/#5-closing-a-position","text":":: stub","title":"5. Closing a position:"},{"location":"user_guide/old/6_generating_reports/","text":"6. Generating report notifications: :: stub","title":"6. Generating report notifications:"},{"location":"user_guide/old/6_generating_reports/#6-generating-report-notifications","text":":: stub","title":"6. Generating report notifications:"},{"location":"user_guide/old/7_creating_a_new_strategy/","text":"Creating a new strategy :: stub [TODO] : Write some content here which explains: How to create a new strategy by extending the BaseStrategy() class eg. class N2SuperTrend(BaseStrategy) How to initialize those strategies in __main__.py with different configurations eg. from strategies.n2_supertrend import N2SuperTrend # initialize using default configuration read from user/user-config.ini strategy = N2SuperTrend () # another way to initialize (eg. for backtesting if that gets implemented): strategy = N2SuperTrend ( params = { # TODO: Document which params need to go in here. This isn't really needed # at this point but might be helpful later })","title":"Creating a new strategy"},{"location":"user_guide/old/7_creating_a_new_strategy/#creating-a-new-strategy","text":":: stub","title":"Creating a new strategy"},{"location":"user_guide/old/7_creating_a_new_strategy/#todo","text":"Write some content here which explains: How to create a new strategy by extending the BaseStrategy() class eg. class N2SuperTrend(BaseStrategy) How to initialize those strategies in __main__.py with different configurations eg. from strategies.n2_supertrend import N2SuperTrend # initialize using default configuration read from user/user-config.ini strategy = N2SuperTrend () # another way to initialize (eg. for backtesting if that gets implemented): strategy = N2SuperTrend ( params = { # TODO: Document which params need to go in here. This isn't really needed # at this point but might be helpful later })","title":"[TODO]:"}]}