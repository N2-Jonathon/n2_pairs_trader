{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home: In these docs I will explain how this program works and its architecture, and try to make it easy to understand for both users or developers. This initially started out as a way to implement a single strategy ie. the SuperTrend Long/Short Strategy, but it's designed in a way to be scalable for use with other strategies and exchanges, and have things abstracted in such a way that each strategy only needs to deal with checking indicator signals, and opening/closing positions, instead of having to think about the underlying trades that comprise the positionsn while writing new strategy. It will also generate a report whenever a trade is opened or closed, then save it to a log file, and if notifications are enabled then it will send notifications either via email or telegram or both including information about each position, which strategy it's from, which pair, the signals taken, trades opened, timestamps, PnL, etc It should be possible out of the box to use margin trading for any exchange which ccxt has implemented that for, which unfortunately is not unified nor implemented for some exchanges, unlike some other unified methods for things like fetching market data, opening trades, etc. - Unfortunately, KuCoin falls into that category of not having margin trading implemented currently, so I've had to implement that myself by: - extending the default ccxt.kucoin in core.exchanges.kucoin_extended and overriding the methods so that it does still support margin trading. the default method ccxt uses for margin trading is exchange.fetch_borrow_rate() but KuCoin's API doesn't have that, and it's only possible to get the max borrow amount - I've added a new method KuCoinExtended.fetch_max_borrow_amount , and I'm going to override the fetch_borrow_rate() method so that it calculates what the rate would be if that's possible? And then it would be possible for me to unify how all the strategies are implemented in this codebase so they always use the same abstractions. I should make a wrapper method which handles which one to use but for now that has to be done inside the strategy.","title":"Readme"},{"location":"#home","text":"In these docs I will explain how this program works and its architecture, and try to make it easy to understand for both users or developers. This initially started out as a way to implement a single strategy ie. the SuperTrend Long/Short Strategy, but it's designed in a way to be scalable for use with other strategies and exchanges, and have things abstracted in such a way that each strategy only needs to deal with checking indicator signals, and opening/closing positions, instead of having to think about the underlying trades that comprise the positionsn while writing new strategy. It will also generate a report whenever a trade is opened or closed, then save it to a log file, and if notifications are enabled then it will send notifications either via email or telegram or both including information about each position, which strategy it's from, which pair, the signals taken, trades opened, timestamps, PnL, etc It should be possible out of the box to use margin trading for any exchange which ccxt has implemented that for, which unfortunately is not unified nor implemented for some exchanges, unlike some other unified methods for things like fetching market data, opening trades, etc. - Unfortunately, KuCoin falls into that category of not having margin trading implemented currently, so I've had to implement that myself by: - extending the default ccxt.kucoin in core.exchanges.kucoin_extended and overriding the methods so that it does still support margin trading. the default method ccxt uses for margin trading is exchange.fetch_borrow_rate() but KuCoin's API doesn't have that, and it's only possible to get the max borrow amount - I've added a new method KuCoinExtended.fetch_max_borrow_amount , and I'm going to override the fetch_borrow_rate() method so that it calculates what the rate would be if that's possible? And then it would be possible for me to unify how all the strategies are implemented in this codebase so they always use the same abstractions. I should make a wrapper method which handles which one to use but for now that has to be done inside the strategy.","title":"Home:"},{"location":"Logical_Sequence/","text":"Sequence of Events: From a terminal, run python __main__.py main() function is called with no params. It also takes the optional param strategy . When it's not specified, it currently defaults to def main(strategy=N2SuperTrend()) which initializes the strategy with the values set in the user config. At this point, you can access the following Fields inherited by StrategyBase: ```python strategy.exchange: str, strategy.strategy_name: str, strategy.prompt_for_pairs: bool, strategy.base_pair: str, strategy.quote_pair: str, strategy.synth_pair: str, # Not sure if this is set properly by init yet strategy.stake_currency: str, strategy.paper_trade: bool, strategy.position_manager: PositionManager, strategy.previous_tick: datetime, strategy.ohlcv_data: dict, strategy.signal: str, strategy.multi_timeframe_mode: bool strategy.multi_timeframe_signal_rules: dict ``` 4. hello","title":"Logical Sequence"},{"location":"Logical_Sequence/#sequence-of-events","text":"From a terminal, run python __main__.py main() function is called with no params. It also takes the optional param strategy . When it's not specified, it currently defaults to def main(strategy=N2SuperTrend()) which initializes the strategy with the values set in the user config. At this point, you can access the following Fields inherited by StrategyBase: ```python strategy.exchange: str, strategy.strategy_name: str, strategy.prompt_for_pairs: bool, strategy.base_pair: str, strategy.quote_pair: str, strategy.synth_pair: str, # Not sure if this is set properly by init yet strategy.stake_currency: str, strategy.paper_trade: bool, strategy.position_manager: PositionManager, strategy.previous_tick: datetime, strategy.ohlcv_data: dict, strategy.signal: str, strategy.multi_timeframe_mode: bool strategy.multi_timeframe_signal_rules: dict ``` 4. hello","title":"Sequence of Events:"},{"location":"creating_a_new_strategy/","text":"Creating a new strategy :: stub TODO: Write some content here which explains: - [ ] How to create a new strategy by extending the BaseStrategy() class eg. class N2SuperTrend(BaseStrategy) - [ ] How to initialize those strategies in __main__.py with different configurations eg. ```python from strategies.n2_supertrend import N2SuperTrend # initialize using default configuration read from user/user-config.ini strategy = N2SuperTrend() # another way to initialize (eg. for backtesting if that gets implemented): strategy = N2SuperTrend(params={ # TODO: Document which params need to go in here. This isn't really needed # at this point but might be helpful later }) ```","title":"Creating a new strategy"},{"location":"creating_a_new_strategy/#creating-a-new-strategy","text":":: stub","title":"Creating a new strategy"},{"location":"creating_a_new_strategy/#todo","text":"Write some content here which explains: - [ ] How to create a new strategy by extending the BaseStrategy() class eg. class N2SuperTrend(BaseStrategy) - [ ] How to initialize those strategies in __main__.py with different configurations eg. ```python from strategies.n2_supertrend import N2SuperTrend # initialize using default configuration read from user/user-config.ini strategy = N2SuperTrend() # another way to initialize (eg. for backtesting if that gets implemented): strategy = N2SuperTrend(params={ # TODO: Document which params need to go in here. This isn't really needed # at this point but might be helpful later }) ```","title":"TODO:"}]}